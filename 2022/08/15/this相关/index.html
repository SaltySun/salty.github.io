<!DOCTYPE html><html lang="zh-cn" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>this相关 | Dr.SlatySun</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="referrer" content="no-referrer"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Dr.SlatySun" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>this相关</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-08-14T16:00:00.000Z" id="date"> 2022-08-15</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-03-24T06:57:38.116Z" id="updated"> 2023-03-24</time></div></span></div></div><hr><div id="post-content"><h2 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是this？</h2><p>在JavaScript中，全局里的this都指向最顶层（浏览器中即window）。</p>
<h2 id="关于绑定"><a href="#关于绑定" class="headerlink" title="关于绑定"></a>关于绑定</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">function f00() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var a = 2;<br><br>foo(); // 2<br></code></pre></td></tr></table></figure>
<p>在全局作用域下用 var 关键字声明的变量和在全局声明的 函数 会被挂载到全局对象(window)上。调用 foo() 时,我们都知道,全局声明的函数的作用域是顶层的 globalObject 在浏览器中也就是 window。<br>在代码中,foo() 是直接使用不带任何修饰的函数引用进行调用的,因此只能使用默认绑定,所以函数中的 this 为 window,也就是 window.a,所以自然而然的就输出 2 了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">function f00() &#123;<br>  &quot;use strict&quot;;<br><br>  console.log(this.a);<br>&#125;<br><br>var a = 2;<br><br>f00(); // Cannot read properties of undefined (reading &#x27;a&#x27;)<br><br>// 因为严格默认情况下,默认绑定,this会被绑定为 undefined ,所以this.a也就等于undivided.a<br>// 因为 undefined 下没有 a 的属性,所以会报类型错误<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">function f00() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var a = 2;<br><br>(function () &#123;<br>  &quot;use strict&quot;;<br>  f00(); // 2<br>&#125;)();<br>  //如果 foo()运行在非 strict mode 下时,默认绑定才能绑定到全局对象,在严格模式 foo() 则不影响默认绑定。<br></code></pre></td></tr></table></figure>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>隐式绑定的规则是调用位置是否有上下文对象,或者说是否被某个对象拥有或者包含。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var obj = &#123;<br>  a: 111,<br>  foo,<br>&#125;;<br><br>obj.foo(); // 111<br></code></pre></td></tr></table></figure>
<p>需要注意的是 foo() 的声明方式,以其之后是如何被当做引用属性添加到 obj 对象中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性,这个函数严格来说都不属于 obj 对象。<br>然而调用位置会使用 obj 上下文来引用函数,因此你可以说函数被调用时 obj 对象 “拥有” 或者 “包含” 函数引用。<br>当函数引用有上下文对象时,隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因此 this.a 和 obj.a 是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var obj2 = &#123;<br>  a: 111,<br>  foo,<br>&#125;;<br><br>var obj1 = &#123;<br>  a: 777,<br>  obj2,<br>&#125;;<br><br>obj1.obj2.foo(); // 111<br><br>// 对象 obj2 为最后一层<br>// obj1.obj2 仅为属性查找,并还没有开始调用<br></code></pre></td></tr></table></figure>
<h4 id="函数脱离原上下文"><a href="#函数脱离原上下文" class="headerlink" title="函数脱离原上下文"></a>函数脱离原上下文</h4><p>一个最常见 this 绑定问题就是被隐式绑定的函数会丢失绑定对象,也就是说他会应用默认绑定默认。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var obj = &#123;<br>  a: 2,<br>  foo,<br>&#125;;<br><br>var bar = obj.foo; // 函数别名<br><br>var a = &quot;我是全局a&quot;;<br><br>bar(); // 我是全局a<br></code></pre></td></tr></table></figure>
<p>虽然 bar 是 obj.foo 的一个引用,但是实际上,它引用的是 foo 函数的本身,因此此时的 bar() 其实是一个普通的函数调用 因此应用了默认绑定。<br>这实际上是重新定义了一个 bar 函数,和对象的结构一样,都是重新赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var obj = &#123;<br>  a: 2,<br>  foo,<br>&#125;;<br><br>var &#123; foo &#125; = obj; // 这里相当于重新定义了一个函数或者说这是一个函数别名<br><br>var a = &quot;我是window下的a&quot;;<br><br>foo(); // 我是window下的a<br><br>var object = &#123;<br>  moment: 777,<br>  age: 18,<br>&#125;;<br><br>console.log(object); // &#123;moment: 777, age: 18&#125;<br>var &#123; moment &#125; = object;<br><br>moment = &quot;牛逼&quot;;<br><br>console.log(moment); // 牛逼<br><br>console.log(object); // &#123;moment: 777, age: 18&#125;<br></code></pre></td></tr></table></figure>
<p>实际上在全局作用域中创建了一个变量 moment 并赋值为 777,后面的直接修改变量不修改对象 object 中的属性 moment。</p>
<h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>function bar(fn) &#123;<br>  // fn 其实是引用 foo<br><br>  fn();<br>&#125;<br><br>var obj = &#123;<br>  a: 777,<br>  foo,<br>&#125;;<br><br>var a = &quot;牛逼啊,这也行&quot;;<br><br>bar(obj.foo); // 牛逼啊,这也行<br></code></pre></td></tr></table></figure>
<p>参数传递其实就是一种隐式赋值,因此我们传入函数时也会被隐式赋值,上面这段代码实际上就是以下代码的变体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>function bar() &#123;<br>  const fn = obj.foo;<br><br>  fn();<br>&#125;<br><br>var obj = &#123;<br>  a: 777,<br>  foo,<br>&#125;;<br><br>var a = &quot;牛逼啊,这也行&quot;;<br><br>bar(); // 牛逼啊,这也行<br></code></pre></td></tr></table></figure>
<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>一般情况下，宿主环境提供的一些函数还是你自己创建的函数,你都可以使用 call(…) 和 apply(…) 方法。<br>他们的第一个参数是一个对象,是给this准备的,接着在调用函数时将其绑定到 this。因为你可以直接指定 this 的绑定对象,因此我们称之为 <strong>显示绑定</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">function foo() &#123;<br>  console.log(this.a);<br>&#125;<br><br>var obj = &#123;<br>  a: 2,<br>&#125;;<br><br>var bar = function () &#123;<br>  foo.call(obj);<br>&#125;;<br><br>bar(); // 2<br>setTimeout(bar, 1000); // 2<br><br>// 硬绑定的 bar 不可能再修改他的 this<br><br>bar.call(window); // 2<br></code></pre></td></tr></table></figure>
<p>许多内置函数,都提供了一个可选的参数,通常成为 上下文,其作用和 bind(…) 一样,确保你的回调函数使用指定的 this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>function callback(element) &#123;<br>  console.log(element, this.id);<br>&#125;<br><br>var obj = &#123;<br>  id: &quot;真不错&quot;,<br>&#125;;<br><br>// 调用 foo(...) 时把 this 绑定到 obj 上<br>[1, 2, 3].forEach(callback, obj);<br>// 1 &#x27;真不错&#x27;  2 &#x27;真不错&#x27;  3 &#x27;真不错&#x27;<br><br>// 俺 map 也一样<br><br>[1, 2, 3].map(callback, obj);<br>// 1 &#x27;真不错&#x27;  2 &#x27;真不错&#x27;  3 &#x27;真不错&#x27;<br><br></code></pre></td></tr></table></figure>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>使用 new 来调用构造函数会执行：</p>
<ol>
<li>在内存中创建一个新对象;</li>
<li>这个新对象内部的 [[prototype]] 特性 被赋值为构造函数的 prototype属性 </li>
<li>构造函数中内部的 this 被赋值为这个新对象(即 this 指向新对象);</li>
<li>执行构造函数内部的代码(给新对象添加属性);</li>
<li><strong><em>如果构造函数返回非空对象,则返回该对象;否则,返回刚创建的新对象;</em></strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>function Foo(moment) &#123;<br>  this.moment = moment;<br>&#125;<br><br>var bar = new Foo(777);<br><br>console.log(bar.a); // 777<br>  // 使用 new 来调用 Foo(...) 时,我们会构造一个新对象并把他绑定到 Foo(...) 调用中的 this 上。<br></code></pre></td></tr></table></figure>
如果构造函数返回一个对象,则该对象将作为整个表达式的值返回,而传入的构造函数的 this 将会被抛弃。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mayDay = &#123;<br>  <span class="hljs-attr">moment</span>: <span class="hljs-string">&quot;moment&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">moment</span> = <span class="hljs-number">777</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">111</span>; <span class="hljs-comment">// 这里的返回值变化了</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">moment</span>); <span class="hljs-comment">// 777 输出的是新对象的 moment</span><br><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数表达式的语法比函数表达式更简洁,并且没有自己的 this, arguments,super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方,并且它不能用作构造函数。正是因为箭头函数没有 this,自然而然的就不能使用 new 操作符了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> moment = <span class="hljs-string">&quot;moment&quot;</span>;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>  <span class="hljs-attr">moment</span>: <span class="hljs-number">777</span>,<br>  <span class="hljs-attr">general</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">moment</span>);<br>  &#125;,<br>  <span class="hljs-attr">arrow</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">moment</span>);<br>  &#125;,<br>  <span class="hljs-attr">nest</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">moment</span>);<br>    &#125;;<br>    <span class="hljs-title function_">callback</span>();<br>  &#125;,<br>&#125;;<br><br>bar.<span class="hljs-title function_">general</span>(); <span class="hljs-comment">// 777</span><br>bar.<span class="hljs-title function_">arrow</span>(); <span class="hljs-comment">// moment</span><br>bar.<span class="hljs-title function_">nest</span>(); <span class="hljs-comment">// 777</span><br><br></code></pre></td></tr></table></figure>
<h2 id="apply，bind-以及-call"><a href="#apply，bind-以及-call" class="headerlink" title="apply，bind 以及 call"></a>apply，bind 以及 call</h2><p>apply和call的用法大同只不过传入的参数不同。<br>apply的第二个参数传的是参数类数组，call是多个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, ...)<br><span class="hljs-keyword">function</span>.<span class="hljs-title function_">apply</span>(thisArg, [argArray])<br></code></pre></td></tr></table></figure>
<p>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">var</span> a =&#123;<br>      name : <span class="hljs-string">&quot;Cherry&quot;</span>,<br>      fn : <span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + b)<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> b = a.<span class="hljs-property">fn</span>;<br>  b.<span class="hljs-title function_">call</span>(a,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)       <span class="hljs-comment">// 3</span><br>b.<span class="hljs-title function_">apply</span>(a,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])       <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。<br><strong>引用MDN上的</strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E6%8F%8F%E8%BF%B0"><strong>描述</strong></a><strong>：</strong><br><strong>bind()</strong> 函数会创建一个新的<strong>绑定函数</strong>（<strong>bound function</strong>，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用<strong>绑定函数</strong>通常会导致执行<strong>包装函数</strong>。 <strong>绑定函数</strong>具有以下内部属性：</p>
<ul>
<li><strong>[[BoundTargetFunction]]</strong> - 包装的函数对象</li>
<li><strong>[[BoundThis]]</strong> - 在调用包装函数时始终作为 <strong>this</strong> 值传递的值。</li>
<li><strong>[[BoundArguments]]</strong> - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。</li>
<li><strong>[[Call]]</strong> - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个<strong>this</strong>值和一个包含通过调用表达式传递给函数的参数的列表。</li>
</ul>
<p>当调用绑定函数时，它调用 <strong>[[BoundTargetFunction]]</strong> 上的内部方法 **[[Call]]**，就像这样 <strong>Call(<em>boundThis</em>, <em>args</em>)<strong>。其中，</strong>boundThis</strong> 是 <strong>[[BoundThis]]<strong>，</strong>args</strong> 是 <strong>[[BoundArguments]]</strong> 加上通过函数调用传入的参数列表。<br>绑定函数也可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a> 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a =&#123;<br>    name : <span class="hljs-string">&quot;Cherry&quot;</span>,<br>    fn : <span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + b)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> b = a.<span class="hljs-property">fn</span>;<br>b.<span class="hljs-title function_">bind</span>(a,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)()           <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/09/03/uni-app%E6%90%9C%E7%B4%A2%E9%A1%B5%E9%9D%A2%EF%BC%88%E6%9C%AC%E5%9C%B0%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%BC%93%E5%AD%98%EF%BC%89/">← Next uni-app搜索页面（本地历史记录缓存）</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/08/14/%E4%BB%8Epromise%E5%88%B0async/">从promise到async Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Salty Sun</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFthis%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是this？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%91%E5%AE%9A"><span class="toc-number">2.</span> <span class="toc-text">关于绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">2.1.</span> <span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.</span> <span class="toc-text">隐式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%84%B1%E7%A6%BB%E5%8E%9F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.2.1.</span> <span class="toc-text">函数脱离原上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">函数作为参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">显示绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E7%BB%91%E5%AE%9A"><span class="toc-number">2.4.</span> <span class="toc-text">new绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply%EF%BC%8Cbind-%E4%BB%A5%E5%8F%8A-call"><span class="toc-number">4.</span> <span class="toc-text">apply，bind 以及 call</span></a></li></ol></div></div><footer><nobr>使用 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>博士 <a target="_blank" rel="noopener" href="https://github.com/SaltySun">SaltySun</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>