<!DOCTYPE html><html lang="zh-cn" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>微信支付详解 | Dr.SlatySun</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="referrer" content="no-referrer"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Dr.SlatySun" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>微信支付详解</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-09-24T16:00:00.000Z" id="date"> 2022-09-25</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-03-24T06:54:36.042Z" id="updated"> 2023-03-24</time></div></span></div></div><hr><div id="post-content"><p>一．概论<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29366599/1660877398383-268be2ff-b992-4d6d-aca3-dd6fcd60c01e.png#id=cWmYA&originHeight=296&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol>
<li>Native支付：</li>
</ol>
<p>商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式<br>返回说明：微信接口返回 url 链接（wxpay:&#x2F;&#x2F;）   前端根据url生成对应的二维码,用户扫码支付</p>
<ol>
<li>付款码支付：</li>
</ol>
<p>用户出示微信钱包中的条码、二维码，商家通过扫描用户条码即可完成收款<br>返回说明：（客户出示微信的条码，商家通过扫码机扫码完成支付）<br>备注：条码扫码机原理：扫码机在扫码时会识别条码里包含的数字+回车键事件（举例：input输入框监听回车键按键事件）</p>
<ol>
<li>H5支付：</li>
</ol>
<p>商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。<br>返回支付H5 url链接，用户跳转到url界面去唤醒支付</p>
<ol>
<li>APP支付：</li>
</ol>
<p>商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。<br>在APP内直接通过activity唤醒微信模块内支付模块<br>(每一个APP软件的每一个界面都是一个activity，另一个APP可以通过)</p>
<ol>
<li>小程序支付:</li>
</ol>
<p>在微信内打开小程序时，可以调用微信支付完成下单购买的流程<br>微信小程序内调起微信支付接口</p>
<p>二．详情<br>以下已小程序支付为例说明<br>①V2版本<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29366599/1660877398935-a670a51b-8a63-47d5-8645-95598a43a78e.png#id=Fn2I1&originHeight=267&originWidth=297&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>V2版本介绍：（本公司项目目前皆使用的是V2版本）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29366599/1660877399538-0e233268-c411-4413-964e-665cc1a6152a.png#id=soTAj&originHeight=175&originWidth=223&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><em>V2版本默认是不需要配置证书的 ，但是配置了证书后必须使用证书方式进行调用<br>接口说明：<br>第一步：（前端小程序功能）小程序调起支付<br>wx.requestPayment<br>(<br>    {<br>        &#x2F;&#x2F;时间戳<br>“timeStamp”: “1414561699”,<br>&#x2F;&#x2F;随机字符串，不长于32位。<br>        “nonceStr”: “5K8264ILTKCH16CQ2502SI8ZNMTM67VS”,<br>         &#x2F;&#x2F;小程序下单接口返回的prepay_id参数值，提交格式如：prepay_id&#x3D;</em>** <br>    &#x2F;&#x2F;该参数由微信支付统一下单接口返回（如附注一）<br>“package”: “prepay_id&#x3D;wx201410272009395522657a690389285100”,<br>&#x2F;&#x2F;签名类型，默认为HMAC256和MD5。<br>        “signType”: “MD5”,<br>         &#x2F;&#x2F;该sign通过加密算法生成<br>        “paySign”: “oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq/xDg&#x3D;&#x3D;”,<br>        “success”:function(res){},<br>        “fail”:function(res){},<br>        “complete”:function(res){}<br>    }<br>)<br>附注一：<br>统一下单接口获取prepay_id<br>统一下单接口url：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/pay/unifiedorder">https://api.mch.weixin.qq.com/pay/unifiedorder</a><br>参数说明：<br>‘appid’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID<br>‘mch_id’ &#x3D;&gt; $this-&gt;mch_id, &#x2F;&#x2F;商户号<br>nonce_str’ &#x3D;&gt; $this-&gt;createNoncestr(), &#x2F;&#x2F;随机字符串<br>‘body’ &#x3D;&gt; $this-&gt;body,<br>‘out_trade_no’ &#x3D;&gt; ‘2018013106125348’, &#x2F;&#x2F;商户订单号<br>‘total_fee’ &#x3D;&gt;100, &#x2F;&#x2F;总金额 单位 分<br>‘spbill_create_ip’ &#x3D;&gt; ‘192.168.0.161’, &#x2F;&#x2F;终端 IP<br>‘notify_url’ &#x3D;&gt;‘’, &#x2F;&#x2F;通知地址  确保外网能正常访问<br>‘openid’ &#x3D;&gt; $this-&gt;openid, &#x2F;&#x2F;用户 id<br>‘trade_type’ &#x3D;&gt; ‘JSAPI’&#x2F;&#x2F;交易类型<br>‘sign’&#x3D;&gt;根据以上参数生成<br>（如果配置了证书：<br>ssl_key_addr：‘’，<br>ssl_cert_addr：‘’ 记得是证书的绝对地址而不是证书里面的内容 v3版本使用的是证书里的内容）<br>备注：①sign的生成算法（注意这个sign并不是小程序所需要的paysign而是统一下单接口需要的sign）<br>将以上参数去掉sign参数后  进行按字典序排序后去掉空格  在转为appid&#x3D;123&amp;mch_id&#x3D;123123&amp;…&amp;trade_type&#x3D;JSAPI形式的字符串str；再在字符串str后拼接key 得到新的字符串str（appid&#x3D;123&amp;mch_id&#x3D;123123&amp;…&amp;trade_type&#x3D;JSAPI&amp;key&#x3D;12312313）<br>最后将得到的str进行md5加密 得到所谓的sign<br>②注意v2版本 提交给微信的并非是我们常见的json形式的数据而是xml格式<br>（xml教程：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/xml/index.asp">https://www.w3school.com.cn/xml/index.asp</a>）<br>以上接口成功后会拿到所需要的prepay_id<br>有了prepay_id后  我们就还剩一个参数没有 那便是小程序调起支付所需要的paysign<br>此时需要在根据上面sign的生成算法 根据值生成一个小程序使用的paysign<br>学名把它叫做 二次验签 参数如下<br> ‘appId’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID<br> ‘timeStamp’ &#x3D;&gt; ‘’ . time() . ‘’, &#x2F;&#x2F;时间戳<br> ‘nonceStr’ &#x3D;&gt; $this-&gt;createNoncestr(), &#x2F;&#x2F;随机串<br> ‘package’ &#x3D;&gt; ‘prepay_id&#x3D;’, &#x2F;&#x2F;数据包（上面拿到的prepay_id）<br> ‘signType’ &#x3D;&gt; ‘MD5’&#x2F;&#x2F;签名方式</p>
<p>到此：小程序所需要的所有参数已经全部获取  直接调用即可拉起微信支付<br>②V3<br>V3接口是最近出来的新的方式，v3的sign生成算法和v2的逻辑上有着本质的区别<br>只要一个一样的  那就是都需要二次验签，具体区别如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29366599/1660877400485-26329e4b-1d33-4b5e-8a3b-63236bbe62c3.png#id=MvMyK&originHeight=242&originWidth=713&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>可以看到  ①v3 已经放弃了你们常见的MD5  而改用最新的RSA+SHA256(俗称RSA2加密方式)②v2的所有返回结果都是明文的xml  v3改成了加密后的json但是需要解密后才能拿到真正的返回值（解密算法AES-256-GCM）<br>具体流程如下：<br>第一步：（前端小程序功能）小程序调起支付<br>wx.requestPayment<br>(<br>    {<br>        &#x2F;&#x2F;时间戳<br>“timeStamp”: “1414561699”,<br>&#x2F;&#x2F;随机字符串，不长于32位。<br>        “nonceStr”: “5K8264ILTKCH16CQ2502SI8ZNMTM67VS”,<br>         &#x2F;&#x2F;小程序下单接口返回的prepay_id参数值，提交格式如：prepay_id&#x3D;*** <br>    &#x2F;&#x2F;该参数由微信支付统一下单接口<br>“package”: “prepay_id&#x3D;wx201410272009395522657a690389285100”,<br>&#x2F;&#x2F;签名类型<br>        “signType”: “RSA”,(只能RSA)<br>         &#x2F;&#x2F;该sign通过加密算法生成<br>        “paySign”: “oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq/xDg&#x3D;&#x3D;”,<br>        “success”:function(res){},<br>        “fail”:function(res){},<br>        “complete”:function(res){}<br>    }<br>)</p>
<p>这个功能  其实和v2的参数大相径庭  重点依旧是获取prepay_id  和  paysign<br>也就是重点是从后面开始 会有截然不同的体现<br>jsapi下单接口url：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a><br>参数：<br>‘appid’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID<br>‘mch_id’ &#x3D;&gt; $this-&gt;mch_id, &#x2F;&#x2F;商户号<br>‘description’ &#x3D;&gt; 商品描述,<br>‘out_trade_no’ &#x3D;&gt; ‘2018013106125348’, &#x2F;&#x2F;商户订单号<br>‘notify_url’ &#x3D;&gt;‘’, &#x2F;&#x2F;通知地址  确保外网能正常访问<br>‘payer’：{‘openid’ &#x3D;&gt; $this-&gt;openid}, &#x2F;&#x2F;用户 id<br>‘amount：{‘total’ &#x3D;&gt; 100}, &#x2F;&#x2F;金额<br>例如：<br>{<br>    “mchid”: “1900006XXX”,<br>    “out_trade_no”: “1217752501201407033233368318”,<br>    “appid”: “wxdace645e0bc2cXXX”,<br>    “description”: “Image形象店-深圳腾大-QQ公仔”,<br>    “notify_url”: “<a target="_blank" rel="noopener" href="https://weixin.qq.com/">https://weixin.qq.com/</a>“,<br>    “amount”: {<br>        “total”: 1,<br>        “currency”: “CNY”<br>    },<br>    “payer”: {<br>        “openid”: “o4GgauInH_RCEdvrrNGrntXDuXXX”<br>    }<br>}<br>这就是所有要传入的参数 细心的你们会发现 参数里并没有发现sign<br>那么v3的接口到底如何调用  我们需要的sign又是如何生成的呢？？？<br>具体的如下：</p>
<ol>
<li>第一步：</li>
</ol>
<p>我们有了以上的参数后 就可以进行签名（第一次签名）<br>第一次签名 并不再是单纯的依靠我们的参数进行签名  ，而是已一种http协议格式的字符串进行签名：例如<br>HTTP请求方法\n URL\n 请求时间戳\n 请求随机串\n 请求报文主体\n<br>以上的  请求方法：get&#x2F;post<br>        url  网关<br>请求时间戳（自主生成）&#x2F;请求随机串（自主生成）&#x2F;报文主体：我们的参数<br>对这个字符串先进行sha256编码在对编码后的字符串进行rsa加密<br>得到的第一次签名的sign<br>备注：这个sign并不需要加入到参数中  ，而是在我们向微信提交请求时 放在请求头中<br>auth_info &#x3D; ‘WECHATPAY2-SHA256-RSA2048 {}’.format(sign)<br>headers[‘Authorization’] &#x3D; auth_info<br>如此我们便能得到prepay_id，那么就还是小程序所需要的paysign<br>那么小程序所需要的paysign  在v3的接口里是怎么生成的呢<br>如下：当我们拿到prepay_id以后<br>我们需要拼接一个这样格式的字符串：<br>‘{}\n{}\n{}\n{}\n’.format(self.mch_appid, ts, nonce, prepay_id)<br>举例： Appid\n时间戳\随机字符串\nprepay_id&#x3D;******<br>对上面所诉的字符串在进行签名得到小程序调起支付所需要的paysign<br>返给前端：至此v3版本支付功能结束<br>由于V3版本设计到了RSA和sha256等算法，这两种算法都封装于openssl里面<br>Sha256  把一个字符串进行sha256后会成为一个256bit的哈希值（跟md5一样不可逆）<br>比如：A7FCFC6B5269BDCCE571798D618EA219A68B96CB87A0E21080C2E758D23E4CE9<br>Rsa ①则是一种对称加密算法 之然而然  就会有加密的密钥 和 解密的密钥（rsa的密钥存放在证书里））②传统的rsa 最开始是1028位的 ，最新的暴力破解已经尝试到了986位，所以 微信使用的全是最新的rsa256（密钥长度为 2056位）（这一点跟支付宝一样，支付宝提供个人沙箱环境 只支持rsa256加密））</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/11/25/%E5%85%BC%E8%81%8C%E4%BF%A1%E6%81%AFaes%20rsa%E5%8A%A0%E5%AF%86%E5%8F%8Awebsocket%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%9E%E7%8E%B0/">← Next 兼职信息aes rsa加密及websocket简易聊天实现</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/09/11/uni-app%20%E9%A1%B6%E9%83%A8%E6%BB%91%E5%8A%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%BB%84%E4%BB%B6/">uni-app 顶部滑动导航栏组件 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Salty Sun</a></h1><div id="description"><p></p></div></div><div id="aside-block"></div><footer><nobr>使用 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>博士 <a target="_blank" rel="noopener" href="https://github.com/SaltySun">SaltySun</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>