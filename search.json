[{"title":"大陆的稀有材料设定","url":"/2023/03/23/%E5%A4%A7%E9%99%86%E7%9A%84%E7%A8%80%E6%9C%89%E6%9D%90%E6%96%99%E8%AE%BE%E5%AE%9A/","content":"锋锐石&#x2F;防护石蕴含魔法但却对立的两种矿石，被加工后是最简单的附魔物品用与短暂的提升物品性能。\n燃烧宝石较为通用的能源矿石，主要用于维持城市的能源稳定，但由于其体积小，能量庞大而不稳定的特性，也十分被普通人应用。\n莱因的软黄金遗失的锻造手法，那位名为莱因的工匠在死之前，留下一份神秘的软黄金，几乎没有人能够复制，而这又是锻造传说物品最重要的一件原料。\n储法石蕴含着奥法秩序的石头，经过施法者编织可以储存相应法术。\n灵魂矿石诞生于深渊，是领主们用来封印灵魂最好的材质，在注满灵魂后，是最棒的交易货币。\n混沌原石只有在混沌海深处能够采集得到，但是进入混沌海的人都会被来自“时间另一头”的生物袭击，所以少有人能活着将石头带回来。\n流彩之石大陆上较为常见的元素矿石，能够改变一个物件本身的元素，这里的常见也仅仅是和其他材料相比，本身还是较为罕见的，一般诞生于元素生物汇聚的地方。\n龙命石出现于龙族死亡的地方，一般伴随着巨大的龙威，其中蕴含着一条巨龙死亡之前的所有力量，只有少部分人能够使用其中的力量。\n生命结晶只有诞生于生命之境的树精死亡才能留下，其中庞大的生命之力能够让人几乎永生。\n秩序结晶传说为神的尸体。\n","categories":["DND"],"tags":["荒域"]},{"title":"关于世界","url":"/2021/04/15/%E5%85%B3%E4%BA%8E%E4%B8%96%E7%95%8C/","content":"荒域四极城，宗教体制下的国家，国家之间通常不会发生战争，小国除外，教会不会插手极城以外的国家纠纷。在2千年之前，据传邪恶龙神的和四神带领的一种神灵开战，大陆上民不聊生，在战争的末期，以四神胜利，龙神被斩下了5头，其余小神的消逝为结束。\n时间一天固定由教会定制的24小时为计时，以400日为一年，每百日为一季，春夏秋冬，冬季太阳升起的高度会异常的高，而夏季则低。整个大陆像是一个闭环一样太阳从中升起，从中落下。而当太阳完全落下，天穹上会亮起白色冷冽的太阳，没有人知道那个是什么，只是永远的挂在天上。\n货币稀有的矿石永远是硬通货，而在荒域最为流通的还是黄金，由熔铸教会打造的金币是被四大教会所认可的通用货币，在其下面还有银币和铜币，一般一个金币就能买到一个家庭一周的口粮。100铜币&#x3D;1银币100银币&#x3D;1金币100金币&#x3D;1白金币除了常见的金属货币，一些蕴含魔力的矿石也能作为与一些德鲁伊们交易的货币，在东方，生物的核通常比金属货币更加流通。也有一些极少数的深渊崇拜者们，他们会收集死者的灵魂，来与深渊生物做交易，但这样一旦发现将受到教会的通缉。\n魔法与秩序自秩序之神将自身化为荒域的一部分，大陆上便产生了自己独特的施法规则，由于秩序无处不在，一些学者便研究出了将秩序转化为可见的力量，即魔法。\n施法者有些种族天生血液里就有着特殊的力量，不需要外界的秩序的力量，便能产生强大的力量，比如龙族。还有一些有着特殊血脉人类也可能获得一些奇特的力量，但就是这种人，他们是作为神恩最合适的人选。而普通人经过后天的学习，也能掌控秩序的力量来施展法术，不过需要漫长的学习和天赋。最为简单成为施法者的方法就是选择成为一位神明的侍奉者。\n施法规则元素之间有着自己的规则，极东的人称为相生相克，自然的诞生必定需要土地，火焰会毁灭自然，而土地将掩盖火焰，诸如此类。但只要力量强到破坏了秩序或者拥有足够的技巧，就可以无视规则。而除开荒域，生命之境和迷失之境都已经被证实不存在秩序。\n魔法物品由秩序缔造的魔法物品，只需要掌握锻造的规则，神器不管是神造还是人造最终的结果都是一样。和规则一样，拥有足够的力量和技巧都能破坏一件强大的魔法物品。\n国度的宗教尽管法师们都以自己高贵的天赋为傲，冒险者们也将命运掌握在自己手中，但被荒域里的大多民众的需求仍依赖众神眷顾。几乎所有人生活的方方面面都维系于诸神扮演的重要角色，而不管其是强大的领主或是卑微的乞丐。但总会有无信之人出现在这篇大陆上。\n崇拜形式通常普通人出生至死都只会崇拜一个神灵，且大部分的人都会崇拜一个与自己生活地区相关的神灵，比如骑士领的居民都渴望秩序所带来的和平，以铸造为生的人会崇拜锻造之神的馈赠。\n新生或外来的神灵四极神从来都不是唯一存在的神系。一些不同地区的人会崇拜一些不太常见的神灵。在极其罕见的情况下会诞生新的神灵，但是大部分神灵都会庇佑信仰所在的地区，也就是强大的神灵所在的国家越强大。\n神职人员通常教会的构成是：主教、祭祀、教会大骑士、牧师、诗僧等人员构成的，由于神恩的存在，主教在国家能够行使的权利几乎与君主一致。\n神恩通常神灵不是永生的，神灵的权位需要传承，每百年便会为新的神诞生来降下预言。受到神恩的神子神女将来到教会进行仪式，或许有一位将成为新的神，继承神的全部，当谁也不知道具体是什么样的。而新的神将继续为城市降下神恩。\n神佑城所有的城市都有着一位神明为其庇佑，让他们在这荒凉的世界得以长久的存在。一般一座城市会有一位主要被供奉的神，少数宽泛权柄的神不会被专门的城市供奉。\n*极北城&#x2F;*凛冬之神希尔顿掌管北方的寒冷的神明\n以矿石产业为城市的主要收入来源，城内具有防寒结界，是北部最适合居住的城市。其现任主教是冰精灵卡图希娜，掌管北部大小宗教事宜。而北境女皇弗尔斯·修林，掌握北境最大的军权，坐拥白熊军团和苍狼军团看守着北境的龙裔们。在极北城奴隶的贩卖是允许的，但是由于律法的约束并不猖獗。\n城内为三层，核心教会与皇城中心，中层居民与商业区，外层贫民区和农业区混合。\n布莱顿幸运之神\n学者领奥秘之神奥法联盟组织的主要据点，几乎这里所有的居民都掌握有一定程度的魔法，他们守护着最大的奥法力量。\n骑士村&#x2F;领秩序之神秩序之锤组织的主要据点，传闻全村的居民都是骑士，曾经有着非凡的血统祖先，所有的孩童出生即是一位骑士，其一生的事业都将贡献给骑士事业。\n海德尔堡坟墓之神\n极东城大地之神米切尔掌管土地的神明极东城位处荒漠，却有着奇特的景象，在黄沙之中可以种子也可以生长，但生长出来的植被通常寿命极短，这足够种植粮食的现象让极东城也汇聚了东边的不少居民。\n斯派利城人偶之神\n克里堡战争之神\n废墟城诡术之神\n维尔村、狂野之吻自然之神\n混沌城混沌之神\n极西城森林之神朗克\n恩登堡生命之神\n沃特村、布雷村、托马村熔铸之神\n瓦特城狩猎之神\n极南城海洋之神克恩达\n恩琪村风暴之神\n米莱尔村守护之神\n博卓村知识之神\n沃斯利堡权柄之神\n深渊深渊即为下位面，深渊之中大部分都是邪魔和地底生物居住，由四位极具力量的恶魔所统领，不过受限于规则，他们无法离开深渊，弱小的生物可以以几乎不存在的代价往返于深渊和荒域，而在深渊死亡的生物也将和荒域一样进入迷失之境，所以即使是在不崇拜神灵的深渊，死亡之神也在此有着信徒。深渊的凶残生物通常只有通过仪式才能召唤于荒域，代价随着被召唤生物的强大而提升。深渊的原生生物通常为恶魔，其产物称其为魔鬼。\n深渊领主人们不尽然信仰着神灵，也有少部分信仰着更加容易得到恩惠的恶魔们。这群人中的一部分形成了邪教，也有许多以独狼或是小组形式活动。不论他们是什么组织，其共同欲望皆是从无底深渊的万丈邪恶之中获得力量。当普通恶魔恩惠于生物时，通常只能给予比一名自己生命低的生物，而领主们在恩惠上没有上限和限制。依照领主强大的力量，强到弱以此为：\n欺诈领主哈恩索兰恩·弗若克托斯\n恐惧领主卡雷基斯__·穆萨帕\n苦痛领主哈雷姆尔__·博卓斯喀提\n灾厄领主卡图娜拉·西索恩\n迷失之境位于位面间隙，空间里充斥着混沌，没有任何元素在其中。几乎没有边境，无论怎么走都会是原地踏步，只有死亡之神及其仆从才能引导人去往想要的地点。\n死亡之神迷失灵魂的引导者，生者从未见过其真容，死者也无法叙述其真容，不会在意其他位面发生的一切，只会静静的等待着生者到来。也许会和生者达成交易，但交易内容只有死者才能知晓。\n迷失者并非所有的死者灵魂都能得到指引，这些灵魂或许会一直徘徊在迷失之境直到耗尽最后一丝能量真正的消失，或者吞噬其他的灵魂的能量成为强大的不死生物。或许在位面之门洞开时逃逸出去或者被其他更强大的灵魂吞噬。\n天界天界被封印已久，传闻数万年前，天穹又称神族居住于此，后因其他原因消失了，天界也关闭了通向其他位面的大门，没人直到该如何前往此处，但数万年前留下的极少数遗产还是成为了世人发现其存在的证据。\n天穹族天穹一族没有留下存在过的痕迹，但根据其遗物大小人们判断这一族平均身高越100尺左右。由于极少的记载导致人们对其一无所知。\n生命之境诞生生命本源的位面，中等位面的附属位面，为生命的诞生和荒域提供了源源不断的能量，妄想前往生命之境的一切生物都被生命之境给同化吞噬，灵魂也不会留下。但其中唯一的生物，生命古树，会诞下树精这一物种并送到荒域为其散播生命提供便捷。\n自然掌控者荒域中的自然植物都生长于生命力充沛的土地上，而诞生于生命古树的奇异生命，一单出生将被送往荒域，其存在的每一片土地都将充满生命，但由于其弱小的攻击性，导致了很多人对其生出觊觎之心，唯有德鲁伊一族和元素一族会将树精视若上宾。\n生命之源树精一族的生命核心，据说也是诞生自生命之境的一部分，正常服下即可让人重生往返于迷失之境，死亡之神也十分的青睐着这充斥着生命的物件。\n","categories":["DND"],"tags":["荒域"]},{"title":"MD5js文件","url":"/2022/09/05/MD5js%E6%96%87%E4%BB%B6/","content":"! function(n) &#123;\t&quot;use strict&quot;;\tfunction t(n, t) &#123;\t\tvar r = (65535 &amp; n) + (65535 &amp; t);\t\treturn (n &gt;&gt; 16) + (t &gt;&gt; 16) + (r &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; r\t&#125;\tfunction r(n, t) &#123;\t\treturn n &lt;&lt; t | n &gt;&gt;&gt; 32 - t\t&#125;\tfunction e(n, e, o, u, c, f) &#123;\t\treturn t(r(t(t(e, n), t(u, f)), c), o)\t&#125;\tfunction o(n, t, r, o, u, c, f) &#123;\t\treturn e(t &amp; r | ~t &amp; o, n, t, u, c, f)\t&#125;\tfunction u(n, t, r, o, u, c, f) &#123;\t\treturn e(t &amp; o | r &amp; ~o, n, t, u, c, f)\t&#125;\tfunction c(n, t, r, o, u, c, f) &#123;\t\treturn e(t ^ r ^ o, n, t, u, c, f)\t&#125;\tfunction f(n, t, r, o, u, c, f) &#123;\t\treturn e(r ^ (t | ~o), n, t, u, c, f)\t&#125;\tfunction i(n, r) &#123;\t\tn[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32, n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r;\t\tvar e, i, a, d, h, l = 1732584193,\t\t\tg = -271733879,\t\t\tv = -1732584194,\t\t\tm = 271733878;\t\tfor (e = 0; e &lt; n.length; e += 16) i = l, a = g, d = v, h = m, g = f(g = f(g = f(g = f(g = c(g = c(g = c(g = c(\t\t\t\t\tg = u(g = u(g = u(g = u(g = o(g = o(g = o(g = o(g, v = o(v, m = o(m, l = o(\t\t\t\t\t\t\t\t\t\t\t\t\t\tl, g, v, m, n[e], 7, -680876936\t\t\t\t\t\t\t\t\t\t\t\t\t\t), g, v, n[e + 1], 12, -\t\t\t\t\t\t\t\t\t\t\t\t\t389564586), l, g, n[e + 2], 17,\t\t\t\t\t\t\t\t\t\t\t\t606105819), m, l, n[e + 3], 22, -\t\t\t\t\t\t\t\t\t\t\t1044525330), v = o(v, m = o(m, l = o(l, g,\t\t\t\t\t\t\t\t\t\t\t\tv, m, n[e + 4], 7, -176418897), g,\t\t\t\t\t\t\t\t\t\t\tv, n[e + 5], 12, 1200080426), l, g, n[\t\t\t\t\t\t\t\t\t\t\te + 6], 17, -1473231341), m, l, n[e + 7],\t\t\t\t\t\t\t\t\t\t22, -45705983), v = o(v, m = o(m, l = o(l, g, v,\t\t\t\t\t\t\t\t\t\t\tm, n[e + 8], 7, 1770035416), g, v, n[e +\t\t\t\t\t\t\t\t\t\t\t9], 12, -1958414417), l, g, n[e + 10], 17, -\t\t\t\t\t\t\t\t\t\t42063), m, l, n[e + 11], 22, -1990404162), v = o(v,\t\t\t\t\t\t\t\t\t\tm = o(m, l = o(l, g, v, m, n[e + 12], 7,\t\t\t\t\t\t\t\t\t\t\t1804603682), g, v, n[e + 13], 12, -40341101), l,\t\t\t\t\t\t\t\t\t\tg, n[e + 14], 17, -1502002290), m, l, n[e + 15], 22,\t\t\t\t\t\t\t\t\t1236535329), v = u(v, m = u(m, l = u(l, g, v, m, n[e +\t\t\t\t\t\t\t\t\t\t1], 5, -165796510), g, v, n[e + 6], 9, -\t\t\t\t\t\t\t\t\t1069501632), l, g, n[e + 11], 14, 643717713), m, l, n[\t\t\t\t\t\t\t\te], 20, -373897302), v = u(v, m = u(m, l = u(l, g, v, m, n[\t\t\t\t\t\t\t\t\te + 5], 5, -701558691), g, v, n[e + 10], 9,\t\t\t\t\t\t\t\t38016083), l, g, n[e + 15], 14, -660478335), m, l, n[e + 4],\t\t\t\t\t\t\t20, -405537848), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 9],\t\t\t\t\t\t\t5, 568446438), g, v, n[e + 14], 9, -1019803690), l, g, n[e +\t\t\t\t\t\t\t3], 14, -187363961), m, l, n[e + 8], 20, 1163531501), v = u(v, m =\t\t\t\t\t\t\tu(m, l = u(l, g, v, m, n[e + 13], 5, -1444681467), g, v, n[e + 2],\t\t\t\t\t\t\t\t9, -51403784), l, g, n[e + 7], 14, 1735328473), m, l, n[e + 12],\t\t\t\t\t\t20, -1926607734), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 5], 4, -\t\t\t\t\t\t\t378558), g, v, n[e + 8], 11, -2022574463), l, g, n[e + 11], 16,\t\t\t\t\t\t1839030562), m, l, n[e + 14], 23, -35309556), v = c(v, m = c(m, l = c(l,\t\t\t\t\t\tg, v, m, n[e + 1], 4, -1530992060), g, v, n[e + 4], 11, 1272893353), l,\t\t\t\t\tg, n[e + 7], 16, -155497632), m, l, n[e + 10], 23, -1094730640), v = c(v, m = c(\t\t\t\t\t\tm, l = c(l, g, v, m, n[e + 13], 4, 681279174), g, v, n[e], 11, -358537222),\t\t\t\t\tl, g, n[e + 3], 16, -722521979), m, l, n[e + 6], 23, 76029189), v = c(v, m = c(m,\t\t\t\t\t\tl = c(l, g, v, m, n[e + 9], 4, -640364487), g, v, n[e + 12], 11, -421815835), l,\t\t\t\t\tg, n[e + 15], 16, 530742520), m, l, n[e + 2], 23, -995338651), v = f(v, m = f(m, l = f(\t\t\t\t\t\tl, g, v, m, n[e], 6, -198630844), g, v, n[e + 7], 10, 1126891415), l, g, n[e + 14],\t\t\t\t\t15, -1416354905), m, l, n[e + 5], 21, -57434055), v = f(v, m = f(m, l = f(l, g, v, m, n[e +\t\t\t\t\t12], 6, 1700485571), g, v, n[e + 3], 10, -1894986606), l, g, n[e + 10], 15, -1051523), m, l,\t\t\t\tn[e + 1], 21, -2054922799), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 8], 6, 1873313359), g, v,\t\t\t\tn[e + 15], 10, -30611744), l, g, n[e + 6], 15, -1560198380), m, l, n[e + 13], 21, 1309151649), v =\t\t\tf(v, m = f(m, l = f(l, g, v, m, n[e + 4], 6, -145523070), g, v, n[e + 11], 10, -1120210379), l, g, n[e +\t\t\t\t2], 15, 718787259), m, l, n[e + 9], 21, -343485551), l = t(l, i), g = t(g, a), v = t(v, d), m = t(m,\t\t\th);\t\treturn [l, g, v, m]\t&#125;\tfunction a(n) &#123;\t\tvar t, r = &quot;&quot;,\t\t\te = 32 * n.length;\t\tfor (t = 0; t &lt; e; t += 8) r += String.fromCharCode(n[t &gt;&gt; 5] &gt;&gt;&gt; t % 32 &amp; 255);\t\treturn r\t&#125;\tfunction d(n) &#123;\t\tvar t, r = [];\t\tfor (r[(n.length &gt;&gt; 2) - 1] = void 0, t = 0; t &lt; r.length; t += 1) r[t] = 0;\t\tvar e = 8 * n.length;\t\tfor (t = 0; t &lt; e; t += 8) r[t &gt;&gt; 5] |= (255 &amp; n.charCodeAt(t / 8)) &lt;&lt; t % 32;\t\treturn r\t&#125;\tfunction h(n) &#123;\t\treturn a(i(d(n), 8 * n.length))\t&#125;\tfunction l(n, t) &#123;\t\tvar r, e, o = d(n),\t\t\tu = [],\t\t\tc = [];\t\tfor (u[15] = c[15] = void 0, o.length &gt; 16 &amp;&amp; (o = i(o, 8 * n.length)), r = 0; r &lt; 16; r += 1) u[r] =\t\t\t909522486 ^ o[r], c[r] = 1549556828 ^ o[r];\t\treturn e = i(u.concat(d(t)), 512 + 8 * t.length), a(i(c.concat(e), 640))\t&#125;\tfunction g(n) &#123;\t\tvar t, r, e = &quot;&quot;;\t\tfor (r = 0; r &lt; n.length; r += 1) t = n.charCodeAt(r), e += &quot;0123456789abcdef&quot;.charAt(t &gt;&gt;&gt; 4 &amp; 15) +\t\t\t&quot;0123456789abcdef&quot;.charAt(15 &amp; t);\t\treturn e\t&#125;\tfunction v(n) &#123;\t\treturn unescape(encodeURIComponent(n))\t&#125;\tfunction m(n) &#123;\t\treturn h(v(n))\t&#125;\tfunction p(n) &#123;\t\treturn g(m(n))\t&#125;\tfunction s(n, t) &#123;\t\treturn l(v(n), v(t))\t&#125;\tfunction C(n, t) &#123;\t\treturn g(s(n, t))\t&#125;\tfunction A(n, t, r) &#123;\t\treturn t ? r ? s(t, n) : C(t, n) : r ? m(n) : p(n)\t&#125;\t&quot;function&quot; == typeof define &amp;&amp; define.amd ? define(function() &#123;\t\treturn A\t&#125;) : &quot;object&quot; == typeof module &amp;&amp; module.exports ? module.exports = A : n.md5 = A&#125;(this);\n","categories":["前端"],"tags":["算法"]},{"title":"Nginx+uWSGI部署","url":"/2022/09/05/Nginx+uWSGI%E9%83%A8%E7%BD%B2/","content":"Linux系统为Centos7\n一、Nginx是什么Nginx类似Apache，一样都是一种Web服务器，基于REST架构风格。Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级并且不支持高并发的服务器。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。这些都决定了Apache不可能成为高性能WEB服务器。因此，轻量级高并发服务器Nginx就应运而生了。\n二、Nginx的作用Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。\n三、关于代理说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程。如同生活中租房子，房东把房子交给中介，租客让中介帮忙找房子，这个中介就是代理，被代理的角色就是房东，目标角色就是用户。\n\n正向代理\n\n比如我们要访问国外的网站：Google，我们需要挂VPN。当我们用VPN访问Google的时候，我们的请求会先走到VPN（代理服务器），VPN（代理服务器）去访问Google，然后将访问到的数据传递给我们。这个VPN就是起到了一个正向代理的作用。\n\n反向代理\n\n比如双11的时候我们访问淘宝，同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了：分布式部署。也就是通过部署多台服务器来解决访问人数限制的问题；淘宝网站中大部分功能也是直接使用Nginx进行反向代理实现的。\n\n负载均衡\n\n负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器等，从而共同完成工作任务。\n四、安装 Nginxsudo yum install -y nginx\n\n安装成功后默认的配置文件为：/etc/nginx/nginx.conf\n五、防火墙配置打开防火墙可保护我们的服务器\n\n查看防火墙状态\nfirewall-cmd --state\n\n防火墙开机自启\nsystemctl enable firewalld.service\n\n打开防火墙服务\nsystemctl start firewalld.service\n\n查看防火墙开启的端口\nfirewall-cmd --list-ports\n\n防火墙打开端口\nfirewall-cmd --add-port=80/tcp --add-port=443/tcp\n\n注：部署新服务的同时，也需要在腾讯云或阿里云服务器后台的安全组打开端口\n六、配置Nginx\n修改/etc/nginx/nginx.conf配置文件# 工作进程数worker_processes  4;# 配置事件events &#123;    # 最大连接数    worker_connections  100000;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    # 开启上下文，提升性能    sendfile        on;    # 关闭请求成功日志    access_log      off;    # 长链接断开超时时间    keepalive_timeout  65;    # 配置后端服务    server &#123;        # 监听80端口        listen 80;        # 站点，可配置ip+端口或域名        server_name  xxxx.cn;        charset utf-8;        client_max_body_size 75M;        # 访问80端口的根目录配置        location / &#123;           include uwsgi_params;           proxy_pass http://127.0.0.1:8001;  #端口要和uwsgi里配置的一样           uwsgi_read_timeout 30;        &#125;        location /static/ &#123;           alias /xx/xxxx/static/; #静态资源路径        &#125;    &#125;    # 配置前端服务    server &#123;        # 监听80端口        listen 80;        # 站点，可配置ip+端口或域名        server_name  xxxx.cn;        # 访问80端口的根目录配置        location / &#123;            # 首页文件名            index index.html;            # 项目根目录            root /xxx/xxx;            try_files $uri $uri/ /index.html;        &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;\n\n七、操作 Nginx\n启动Nginx\nsystemctl start nginx\n\n停止Nginx\nsystemctl stop nginx\n\n重启Nginx\nsystemctl restart nginx\n\n查看Nginx状态\nsystemctl status nginx\n\nNginx开机自启\nsystemctl enable nginx\n\n禁用Nginx开机自启\nsystemctl disable nginx\n\nNginx配置文件自检\nnginx -t\n\n八、uWSGI是什么uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。\n九、配置uWSGI\n在项目根目录下创建 uwsgi.ini 配置文件\ntouch uwsgi.ini\n\nuWSGI配置文件例子如下\n[uwsgi]# 同时打开http和socket协议http-socket = 0.0.0.0:8001chdir = 项目根目录# 使进程在后台运行，并将日志打到指定的日志文件daemonize = 日志路径# 启动主进程，来管理其他进程master = true# 启动8个工作进程processes = 8# 启动4个工作线程threads = 4# 当服务器退出的时候自动删除unix socket文件和pid文件vacuum = truepy-autoreload = 1static-map = /static=/xx/xxxx/static# 设置socket的监听队列大小（默认：100）listen = 1000# 一个请求花费的时间超过了该时间，当前工作进程自动重启harakiri = 30# 为每个工作进程设置请求数的上限max-requests = 5000# 设置在平滑重启（直到接收到的请求处理完才重启）reload-mercy = 8\n\n十、操作uWSGI\n运行uWSGI服务uwsgi --ini uwsgi.ini\n\n","categories":["服务器"],"tags":["服务器"]},{"title":"this相关","url":"/2022/08/15/this%E7%9B%B8%E5%85%B3/","content":"什么是this？在JavaScript中，全局里的this都指向最顶层（浏览器中即window）。\n关于绑定默认绑定function f00() &#123;  console.log(this.a);&#125;var a = 2;foo(); // 2\n在全局作用域下用 var 关键字声明的变量和在全局声明的 函数 会被挂载到全局对象(window)上。调用 foo() 时,我们都知道,全局声明的函数的作用域是顶层的 globalObject 在浏览器中也就是 window。在代码中,foo() 是直接使用不带任何修饰的函数引用进行调用的,因此只能使用默认绑定,所以函数中的 this 为 window,也就是 window.a,所以自然而然的就输出 2 了。\nfunction f00() &#123;  &quot;use strict&quot;;  console.log(this.a);&#125;var a = 2;f00(); // Cannot read properties of undefined (reading &#x27;a&#x27;)// 因为严格默认情况下,默认绑定,this会被绑定为 undefined ,所以this.a也就等于undivided.a// 因为 undefined 下没有 a 的属性,所以会报类型错误\nfunction f00() &#123;  console.log(this.a);&#125;var a = 2;(function () &#123;  &quot;use strict&quot;;  f00(); // 2&#125;)();  //如果 foo()运行在非 strict mode 下时,默认绑定才能绑定到全局对象,在严格模式 foo() 则不影响默认绑定。\n隐式绑定隐式绑定的规则是调用位置是否有上下文对象,或者说是否被某个对象拥有或者包含。\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123;  a: 111,  foo,&#125;;obj.foo(); // 111\n需要注意的是 foo() 的声明方式,以其之后是如何被当做引用属性添加到 obj 对象中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性,这个函数严格来说都不属于 obj 对象。然而调用位置会使用 obj 上下文来引用函数,因此你可以说函数被调用时 obj 对象 “拥有” 或者 “包含” 函数引用。当函数引用有上下文对象时,隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因此 this.a 和 obj.a 是一样的。\nfunction foo() &#123;  console.log(this.a);&#125;var obj2 = &#123;  a: 111,  foo,&#125;;var obj1 = &#123;  a: 777,  obj2,&#125;;obj1.obj2.foo(); // 111// 对象 obj2 为最后一层// obj1.obj2 仅为属性查找,并还没有开始调用\n函数脱离原上下文一个最常见 this 绑定问题就是被隐式绑定的函数会丢失绑定对象,也就是说他会应用默认绑定默认。\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123;  a: 2,  foo,&#125;;var bar = obj.foo; // 函数别名var a = &quot;我是全局a&quot;;bar(); // 我是全局a\n虽然 bar 是 obj.foo 的一个引用,但是实际上,它引用的是 foo 函数的本身,因此此时的 bar() 其实是一个普通的函数调用 因此应用了默认绑定。这实际上是重新定义了一个 bar 函数,和对象的结构一样,都是重新赋值\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123;  a: 2,  foo,&#125;;var &#123; foo &#125; = obj; // 这里相当于重新定义了一个函数或者说这是一个函数别名var a = &quot;我是window下的a&quot;;foo(); // 我是window下的avar object = &#123;  moment: 777,  age: 18,&#125;;console.log(object); // &#123;moment: 777, age: 18&#125;var &#123; moment &#125; = object;moment = &quot;牛逼&quot;;console.log(moment); // 牛逼console.log(object); // &#123;moment: 777, age: 18&#125;\n实际上在全局作用域中创建了一个变量 moment 并赋值为 777,后面的直接修改变量不修改对象 object 中的属性 moment。\n函数作为参数function foo() &#123;  console.log(this.a);&#125;function bar(fn) &#123;  // fn 其实是引用 foo  fn();&#125;var obj = &#123;  a: 777,  foo,&#125;;var a = &quot;牛逼啊,这也行&quot;;bar(obj.foo); // 牛逼啊,这也行\n参数传递其实就是一种隐式赋值,因此我们传入函数时也会被隐式赋值,上面这段代码实际上就是以下代码的变体\nfunction foo() &#123;  console.log(this.a);&#125;function bar() &#123;  const fn = obj.foo;  fn();&#125;var obj = &#123;  a: 777,  foo,&#125;;var a = &quot;牛逼啊,这也行&quot;;bar(); // 牛逼啊,这也行\n显示绑定一般情况下，宿主环境提供的一些函数还是你自己创建的函数,你都可以使用 call(…) 和 apply(…) 方法。他们的第一个参数是一个对象,是给this准备的,接着在调用函数时将其绑定到 this。因为你可以直接指定 this 的绑定对象,因此我们称之为 显示绑定\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123;  a: 2,&#125;;var bar = function () &#123;  foo.call(obj);&#125;;bar(); // 2setTimeout(bar, 1000); // 2// 硬绑定的 bar 不可能再修改他的 thisbar.call(window); // 2\n许多内置函数,都提供了一个可选的参数,通常成为 上下文,其作用和 bind(…) 一样,确保你的回调函数使用指定的 this。\nfunction callback(element) &#123;  console.log(element, this.id);&#125;var obj = &#123;  id: &quot;真不错&quot;,&#125;;// 调用 foo(...) 时把 this 绑定到 obj 上[1, 2, 3].forEach(callback, obj);// 1 &#x27;真不错&#x27;  2 &#x27;真不错&#x27;  3 &#x27;真不错&#x27;// 俺 map 也一样[1, 2, 3].map(callback, obj);// 1 &#x27;真不错&#x27;  2 &#x27;真不错&#x27;  3 &#x27;真不错&#x27;\nnew绑定使用 new 来调用构造函数会执行：\n\n在内存中创建一个新对象;\n这个新对象内部的 [[prototype]] 特性 被赋值为构造函数的 prototype属性 \n构造函数中内部的 this 被赋值为这个新对象(即 this 指向新对象);\n执行构造函数内部的代码(给新对象添加属性);\n如果构造函数返回非空对象,则返回该对象;否则,返回刚创建的新对象;function Foo(moment) &#123;  this.moment = moment;&#125;var bar = new Foo(777);console.log(bar.a); // 777  // 使用 new 来调用 Foo(...) 时,我们会构造一个新对象并把他绑定到 Foo(...) 调用中的 this 上。\n如果构造函数返回一个对象,则该对象将作为整个表达式的值返回,而传入的构造函数的 this 将会被抛弃。var mayDay = &#123;  moment: &quot;moment&quot;&#125;function Foo() &#123;  this.moment = 777;  return 111; // 这里的返回值变化了&#125;var bar = new Foo();console.log(bar.moment); // 777 输出的是新对象的 moment\n\n箭头函数箭头函数表达式的语法比函数表达式更简洁,并且没有自己的 this, arguments,super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方,并且它不能用作构造函数。正是因为箭头函数没有 this,自然而然的就不能使用 new 操作符了。\nvar moment = &quot;moment&quot;;var bar = &#123;  moment: 777,  general: function () &#123;    console.log(this.moment);  &#125;,  arrow: () =&gt; &#123;    console.log(this.moment);  &#125;,  nest: function () &#123;    var callback = () =&gt; &#123;      console.log(this.moment);    &#125;;    callback();  &#125;,&#125;;bar.general(); // 777bar.arrow(); // momentbar.nest(); // 777\napply，bind 以及 callapply和call的用法大同只不过传入的参数不同。apply的第二个参数传的是参数类数组，call是多个参数。\nfunction.call(thisArg, arg1, arg2, ...)function.apply(thisArg, [argArray])\nthisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。\n  var a =&#123;      name : &quot;Cherry&quot;,      fn : function (a,b) &#123;          console.log( a + b)      &#125;  &#125;  var b = a.fn;  b.call(a,1,2)       // 3b.apply(a,[1,2])       // 3\nbind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。引用MDN上的描述：bind() 函数会创建一个新的绑定函数（bound function，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。 绑定函数具有以下内部属性：\n\n[[BoundTargetFunction]] - 包装的函数对象\n[[BoundThis]] - 在调用包装函数时始终作为 this 值传递的值。\n[[BoundArguments]] - 列表，在对包装函数做任何调用都会优先用列表元素填充参数列表。\n[[Call]] - 执行与此对象关联的代码。通过函数调用表达式调用。内部方法的参数是一个this值和一个包含通过调用表达式传递给函数的参数的列表。\n\n当调用绑定函数时，它调用 [[BoundTargetFunction]] 上的内部方法 **[[Call]]**，就像这样 Call(boundThis, args)。其中，boundThis 是 [[BoundThis]]，args 是 [[BoundArguments]] 加上通过函数调用传入的参数列表。绑定函数也可以使用 new 运算符构造，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。\nvar a =&#123;    name : &quot;Cherry&quot;,    fn : function (a,b) &#123;        console.log( a + b)    &#125;&#125;var b = a.fn;b.bind(a,1,2)()           // 3\n","categories":["前端"],"tags":["js"]},{"title":"uni-app 顶部滑动导航栏组件","url":"/2022/09/11/uni-app%20%E9%A1%B6%E9%83%A8%E6%BB%91%E5%8A%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%BB%84%E4%BB%B6/","content":"&lt;template&gt;    &lt;view class=&quot;uni-tab-bar&quot;&gt;        &lt;scroll-view class=&quot;uni-swiper-tab&quot; scroll-x=&quot;true&quot;&gt;            &lt;block v-for=&quot;(tab,index) in tabBars&quot; :style=&quot;scrollStyle&quot;&gt;                &lt;view class=&quot;swiper-tab-list&quot; :class=&quot;&#123;&#x27;active&#x27; : tabIndex==index&#125;&quot; @tap=&quot;tabtap(index)&quot;                    :style=&quot;scrollItemStyle&quot;&gt;                    &#123;&#123;tab.name&#125;&#125; &#123;&#123;tab.num?tab.num:&quot;&quot;&#125;&#125;                    &lt;view class=&quot;swiper-tab-line&quot;&gt;&lt;/view&gt;                &lt;/view&gt;            &lt;/block&gt;        &lt;/scroll-view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        props: &#123;            tabBars: Array,            tabIndex: Number,            scrollStyle: &#123;                type: String,                default: &quot;&quot;            &#125;,            scrollItemStyle: &#123;                type: String,                default: &quot;&quot;            &#125;        &#125;,        methods: &#123;            //点击切换导航            tabtap(index) &#123;                // this.tabIndex = index;                this.$emit(&#x27;tabtap&#x27;, index)            &#125;        &#125;    &#125;&lt;/script&gt;　&lt;style&gt;&lt;/style&gt;\n&lt;template&gt;\t    &lt;view class=&quot;content&quot;&gt;\t\t &lt;swiperTabHead :tabBars=&quot;tabBars&quot; :tabIndex=&quot;tabIndex&quot; @tabtap=&quot;tabtap&quot;&gt;&lt;/swiperTabHead&gt;\t\t&lt;swiper class=&quot;swiper-content&quot; :style=&quot;&#123;height:swiperheight+&#x27;rpx&#x27;&#125;&quot; :current=&quot;tabIndex&quot; @change=&quot;swiperChange&quot;&gt;\t\t\t  &lt;swiper-item class=&quot;itemswiper&quot; :key=&quot;index2&quot; v-for=&quot;(newItem ,index2) in tabBars&quot;&gt;\t\t\t\t  &lt;view class=&quot;viewat&quot;&gt;\t\t\t\t\t&#123;&#123;newItem.id&#125;&#125; &#123;&#123;newItem.name&#125;&#125;\t\t\t\t&lt;/view&gt;\t\t\t&lt;/swiper-item&gt;\t\t\t  &lt;/swiper&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport swiperTabHead from &quot;../../components/scrollbar.vue&quot;\texport default &#123;\t\tcomponents: &#123;\t\t\tswiperTabHead\t\t&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tswiperheight: 0,\t\t\t\ttabIndex: 0, // 选中的\t\t\t\ttabBars: [&#123;\t\t\t\t\t\tname: &quot;关注&quot;,\t\t\t\t\t\tid: &quot;guanzhu&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;推荐&quot;,\t\t\t\t\t\tid: &quot;tuijian&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;体育&quot;,\t\t\t\t\t\tid: &quot;tiyu&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;热点咨询&quot;,\t\t\t\t\t\tid: &quot;redian&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;财经&quot;,\t\t\t\t\t\tid: &quot;caijing&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;娱乐&quot;,\t\t\t\t\t\tid: &quot;yule&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;社会&quot;,\t\t\t\t\t\tid: &quot;yule&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;自然&quot;,\t\t\t\t\t\tid: &quot;yule&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;币圈&quot;,\t\t\t\t\t\tid: &quot;yule&quot;\t\t\t\t\t&#125;,\t\t\t\t\t&#123;\t\t\t\t\t\tname: &quot;国家体育&quot;,\t\t\t\t\t\tid: &quot;yule&quot;\t\t\t\t\t&#125;,\t\t\t\t]\t\t\t&#125;\t\t&#125;,\t\tonLoad() &#123;\t\t\tvar _this = this\t\t\tuni.getSystemInfo(&#123;\t\t\t\tsuccess(res) &#123;\t\t\t\t\tconsole.log(&quot;屏幕高度 HH = &quot; + res.windowHeight)\t\t\t\t\tconsole.log(&quot;屏幕高度 HH222 = &quot; + res.windowHeight * 2)\t\t\t\t\t_this.swiperheight = res.windowHeight * 2 - 68\t\t\t\t&#125;\t\t\t&#125;)\t\t&#125;,\t\tmethods: &#123;\t\t\t//接受子组件传过来的值点击切换导航\t\t\ttabtap(index) &#123;\t\t\t\tvar _this = this\t\t\t\t_this.tabIndex = index;\t\t\t&#125;,\t\t\t// 滑动切换导航\t\t\tswiperChange: function(e) &#123;\t\t\t\tvar _this = this\t\t\t\t_this.tabIndex = e.detail.current\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n","categories":["前端"],"tags":["小程序"]},{"title":"uni-app搜索页面（本地历史记录缓存）","url":"/2022/09/03/uni-app%E6%90%9C%E7%B4%A2%E9%A1%B5%E9%9D%A2%EF%BC%88%E6%9C%AC%E5%9C%B0%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%BC%93%E5%AD%98%EF%BC%89/","content":"&lt;template&gt;\t&lt;view class=&quot;container&quot;&gt;\t\t&lt;view class=&quot;search-btn&quot; @click=&quot;focus()&quot;&gt;\t\t\t&lt;uni-search-bar @confirm=&quot;search&quot; bgColor=&quot;#EDEDED&quot; radius=&quot;20&quot; cancelButton=&quot;none&quot; placeholder=&quot;输入模板关键字&quot;\t\t\t\tv-model=&quot;searchValue&quot;&gt; &lt;/uni-search-bar&gt;\t\t&lt;/view&gt;\t\t&lt;view class=&quot;history&quot;&gt;\t\t\t&lt;view class=&quot;title&quot;&gt;\t\t\t\t&lt;text style=&quot;font-weight: 900;&quot;&gt;历史记录&lt;/text&gt;\t\t\t\t&lt;uni-icons type=&quot;trash&quot; size=&quot;20&quot; @click=&quot;clean()&quot;&gt;&lt;/uni-icons&gt;\t\t\t&lt;/view&gt;\t\t\t&lt;view class=&quot;example-body&quot;&gt;\t\t\t\t&lt;view class=&quot;tag-view&quot; v-for=&quot;(item,index) in list&quot; @longpress=&quot;deleted(index)&quot;&gt;\t\t\t\t\t&lt;uni-tag :circle=&quot;true&quot; :text=&quot;item&quot; @click=&quot;tohistory(item)&quot;\t\t\t\t\t\tcustom-style=&quot;background-color: #F4F4F4; border-color:#F4F4F4; color: #2f2f2f;&quot; /&gt;\t\t\t\t&lt;/view&gt;\t\t\t&lt;/view&gt;\t\t&lt;/view&gt;\t\t&lt;uni-popup ref=&quot;popup&quot; type=&quot;dialog&quot;&gt;\t\t\t&lt;uni-popup-dialog mode=&quot;base&quot; message=&quot;成功消息&quot; title=&quot;确认删除？&quot; :duration=&quot;2000&quot; :before-close=&quot;true&quot;\t\t\t\t@close=&quot;close&quot; @confirm=&quot;confirm&quot;&gt;&lt;/uni-popup-dialog&gt;\t\t&lt;/uni-popup&gt;\t\t&lt;uni-popup ref=&quot;clean&quot; type=&quot;dialog&quot;&gt;\t\t\t&lt;uni-popup-dialog mode=&quot;base&quot; message=&quot;成功消息&quot; title=&quot;删除全部历史记录？&quot; :duration=&quot;2000&quot; :before-close=&quot;true&quot;\t\t\t\t@close=&quot;close&quot; @confirm=&quot;clearall&quot;&gt;&lt;/uni-popup-dialog&gt;\t\t&lt;/uni-popup&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tsearchValue: &#x27;&#x27;,\t\t\t\tlist: [],\t\t\t\tindex: &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t// 去重\t\t\tremoveDuplicate(arr) &#123;\t\t\t\tconst newArr = []\t\t\t\tarr.forEach(item =&gt; &#123;\t\t\t\t\tif (newArr.indexOf(item) === -1) &#123;\t\t\t\t\t\tnewArr.push(item)\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t\treturn newArr // 返回一个新数组\t\t\t&#125;,\t\t\tsearch(res) &#123;\t\t\t\tthis.list.push(res.value)\t\t\t\tthis.list = this.removeDuplicate(this.list)\t\t\t\tuni.setStorageSync(&#x27;history&#x27;, this.list)\t\t\t\tuni.navigateTo(&#123;\t\t\t\t\turl:&#x27;../calorie_category/calorie_category?word=&#x27;+ res.value\t\t\t\t&#125;)\t\t\t\tthis.searchValue = &#x27;&#x27;\t\t\t&#125;,\t\t\tdeleted(index) &#123;\t\t\t\tthis.$refs.popup.open()\t\t\t\tthis.index = index\t\t\t&#125;,\t\t\tclean() &#123;\t\t\t\tthis.$refs.clean.open()\t\t\t&#125;,\t\t\tclearall() &#123;\t\t\t\tthis.list = []\t\t\t\tuni.setStorageSync(&#x27;history&#x27;, this.list)\t\t\t\tthis.$refs.clean.close()\t\t\t&#125;,\t\t\tconfirm() &#123;\t\t\t\tthis.list.splice(this.index, 1)\t\t\t\tthis.$refs.popup.close()\t\t\t\tthis.index = &#x27;&#x27;\t\t\t\tuni.setStorageSync(&#x27;history&#x27;, this.list)\t\t\t&#125;,\t\t\tclose() &#123;\t\t\t\tthis.$refs.popup.close()\t\t\t\tthis.$refs.clean.close()\t\t\t&#125;,\t\t\ttohistory(item) &#123;\t\t\t\tuni.navigateTo(&#123;\t\t\t\t\turl:&#x27;../calorie_category/calorie_category?word=&#x27;+ item\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tfocus() &#123;\t\t\t&#125;\t\t&#125;,\t\tonLoad() &#123;\t\t\tif (uni.getStorageSync(&#x27;history&#x27;)) &#123;\t\t\t\tthis.list = uni.getStorageSync(&#x27;history&#x27;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;\t.container &#123;\t\theight: 100%;\t\tbackground-color: white;\t&#125;\t.history &#123;\t\tmargin: 20rpx;\t&#125;\t.title &#123;\t\tdisplay: flex;\t\tjustify-content: space-between;\t\tmargin: 20rpx 0;\t&#125;\t.example-body &#123;\t\tdisplay: flex;\t\tflex-direction: row;\t\tjustify-content: flex-start;\t\talign-items: flex-end;\t\tflex-wrap: wrap;\t&#125;\t.tag-view &#123;\t\tmargin-right: 10px;\t&#125;&lt;/style&gt;\n","categories":["前端"],"tags":["小程序"]},{"title":"uni-app requset请求封装_api封装","url":"/2022/09/05/uni-app%20requset%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85_api%E5%B0%81%E8%A3%85/","content":"import Request from &#x27;../utils/request.js&#x27;import operate from &#x27;./operate.js&#x27;let request = new Request().httpexport const getemoji = function(data) &#123;  return request(&#123;    url: &quot;&quot;,//拼接路径    method: &quot;GET&quot;,    data: data  &#125;)&#125;\nexport default &#123;\t//接口\tapi: &quot;&quot;&#125;\nimport operate from &#x27;../common/operate.js&#x27;// vuex 的使用  详情参考官网 https://uniapp.dcloud.io/vue-vueximport store from &#x27;../store/index.js&#x27;  export default class Request &#123;    http(param) &#123;        // 请求参数        var url = param.url,            method = param.method,            header = &#123;&#125;,            data = param.data || &#123;&#125;,            hideLoading = param.hideLoading || false;        //拼接完整请求地址        var requestUrl = operate.api + url;\t\tconsole.log(requestUrl)       //拼接完整请求地址（根据环境切换）       // var requestUrl = operate.api() + url;        //请求方式:GET或POST(POST需配置        // header: &#123;&#x27;content-type&#x27; : &quot;application/x-www-form-urlencoded&quot;&#125;,)        if (method) &#123;            method = method.toUpperCase(); //小写改为大写            if (method == &quot;GET&quot;) &#123;                header = &#123;                    &#x27;content-type&#x27;: &quot;application/x-www-form-urlencoded&quot;                &#125;;            &#125; else &#123;                header = &#123;                    &#x27;content-type&#x27;: &quot;application/json&quot;                &#125;;            &#125;        &#125;        //加载圈        if (!hideLoading) &#123;            uni.showLoading(&#123;                title: &#x27;加载中...&#x27;            &#125;);        &#125;        // 返回promise        return new Promise((resolve, reject) =&gt; &#123;            // 请求            uni.request(&#123;                url: requestUrl,                data: data,                method: method,                header: header,                success: (res) =&gt; &#123;                    // 判断 请求api 格式是否正确                    if (res.statusCode &amp;&amp; res.statusCode != 200) &#123;                        uni.showToast(&#123;                            title: &quot;api错误&quot; + res.errMsg,                            icon: &#x27;none&#x27;                        &#125;);                        return;                    &#125;                    // 将结果抛出                    resolve(res.data)                &#125;,                //请求失败                fail: (e) =&gt; &#123;                    uni.showToast(&#123;                        title: &quot;&quot; + e.data,                        icon: &#x27;none&#x27;                    &#125;);                    resolve(e.data);                &#125;,                //请求完成                complete() &#123;                    //隐藏加载                    if (!hideLoading) &#123;                        uni.hideLoading();                    &#125;                    resolve();                    return;                &#125;            &#125;)        &#125;)    &#125;&#125;\n","categories":["前端"],"tags":["小程序"]},{"title":"vue3.0 + Ts 入门","url":"/2022/12/29/vue3.0%20+%20Ts%20%E5%85%A5%E9%97%A8/","content":"1.vue3.0与vue2.0区别\nvue2中执行顺序 beforeCreate&#x3D;&gt;created&#x3D;&gt;beforeMount &#x3D;&gt;mounted&#x3D;&gt;beforeUpdate &#x3D;&gt;updated&#x3D;&gt;beforeDestroy&#x3D;&gt;destroyed\nvue3中执行顺序 setup&#x3D;&gt;onBeforeMount&#x3D;&gt;onMounted&#x3D;&gt;onBeforeUpdate&#x3D;&gt;onUpdated&#x3D;&gt;onBeforeUnmount&#x3D;&gt;onUnmounted\n\n生命周期对应关系,后者为vue3.0\n\nbeforeCreate-&gt;setup\ncreated -&gt; setup\nbeforeMount -&gt; onBeforeMount\nmounted -&gt; onMounted\nbeforeUpdate -&gt; onBeforeUpdate\nupdated -&gt; onUpdated\nbeforeDestroy -&gt; onBeforeUnmount\ndestroyed -&gt; onUnmounted\n\nvue2和vue3双向数据绑定原理发生了改变\nvue3.0响应式数据创建通过引入ref和reactiveref针对单个响应式数据,reative针对的是对象\nTS和JS的一些区别typescript 特点\nts是js的超集，即你可以在ts中使用原生js语法。ts需要静态编译，它提供了强类型与更多面向对象的内容。ts最终仍要编译为弱类型的js文件，基于对象的原生的js，再运行。故ts相较java&#x2F;C#这样天生面向对象语言是有区别和局限的ts是由微软牵头主导的，主要来自C#TypeScript和JavaScript的对比：TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义TypeScript可以重用JavaScript代码，调用流行的JavaScript库。\nTypeScript 安装创建一个变量,定义str类型,其他类型同理声明一个变量为数组\nAny 类型\nTypeScript 接口\nTypeScript 对象\nvue3+typescript创建项目详细步骤1、新建一个文件夹；\n2、vue&#x2F;cli全局安装：cnpm install -g @vue&#x2F;cli 或者 npm install -g @vue&#x2F;cli；3、创建项目名称：vue create 项目名称；4、配置文件（根据个人喜好选择）：如图：1）、第一个选项是预设配置项，第一个只包含babel，eslint，要选第二个，可以自由配置。\n\n选择第二项，出现如图配置（空格搭配上下键选择）：\n\nbabel是用来适配一些js的新特性，浏览器还不支持的，但是可以通过其它方式实现它的语法typescript就是启用typescript支持PWA这个是渐进式web应用，如果用不上，不需要选Router是vue-routercss pre-processors是用来支持css预处理器的，less，sass这些linter是用来做代码检验的，如代码缩进，规范合不合格之类的，都是它来校验2）、这2个是自动化测试框架，可以不选；测试代码有没有bug，符不符合预期用的\n\n3）、class-style component syntax，像react的风格，是否启用类作为组件模型，这个建议开启。\n\n4）、配置babel对ts，jsx的转义，要开启\n\n5）、路由管理模式，Y是HTML5 history，N是hash模式\n\n6）、预处理器，根据自己习惯选择；\n\n7）、这个是代码风格约束的选择项;\n\n8）、对git提交时候的风格校验；第一个是保存的时候，第二个是commit的时候推荐2个都开启\n\n9）、置配置文件的管理路径，建议选第一个，每一个单独生成配置文件，第二个都会堆在package.json，\n\n10）、把这些配置是否保存为模板，选择N\n\n11）、成功创建项目；\n\n","categories":["前端"],"tags":["vue"]},{"title":"优雅的响应式数据","url":"/2022/02/02/%E4%BC%98%E9%9B%85%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE/","content":"defineProperty这个obj上的方法可以用来修改指定的对象属性的值语法：Object.defineProperty(obj,property,descriptor)\n参数一：obj绑定属性的目标对象参数二：property绑定的属性名参数三：descriptor属性描述（配置），且此参数本身为一个对象\n属性值1：value设置属性默认值属性值2：writable设置属性是否能够修改属性值3：enumerable设置属性是否可以枚举，即是否允许遍历属性值4：configurable设置属性是否可以删除或编辑属性值5：get获取属性的值属性值6：set设置属性的值\n先定义一个这个玩意\nvar obj = &#123;\tcount : 0,\tlist : [1,2,4]&#125;var target = &#123;&#125;;\n通过value设置属性值由于Object.defineProperty可以给对象定义属性，我们通过value，可以动态地将obj对象的属性动态地添加给target中。\n  for (let key in obj)&#123;\tObject.defineProperty(target,key,&#123;\t\tvalue: obj[key]\t&#125;)&#125;console.log(target);\n通过get方法获取属性的值【注意!】当设置get方法时，不能有value和writable方法，否则会报错get方法的值是一个函数，此函数不需要参数\n  for (let key in obj)&#123;\tObject.defineProperty(target,key,&#123;\t\t//value: obj[key],\t\t//writable:true,\t\tenumerable: false,\t\tconfigurable: true,\t\tget: function()&#123;\t\t\treturn obj[key]\t\t&#125;\t&#125;)&#125;console.log(target.count);\n通过set方法设置属性的值set方法的值也是一个函数，定义时会自动注入一个参数，此参数会设置属性的值\n  for (let key in obj)&#123;\tObject.defineProperty(target,key,&#123;\t\t//value: obj[key],\t\t//writable:true,\t\tenumerable: false,\t\tconfigurable: true,\t\tget: function()&#123;\t\t\treturn obj[key]\t\t&#125;，\t\tset: function(val)&#123;\t\t\tconsole.log(val);//打印设置好的值\t\t&#125;\t&#125;)&#125;target.count = 10;//修改count属性的值为10\nvue2.x的响应式原理在Vue2.X 响应式中使用到了 defineProperty 进行数据劫持，所以我们对它必须有一定的了解，那么我们先来了解它的使用方法把， 这里我们来使用 defineProperty来模拟 Vue 中的 data\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 模拟 Vue的data    let data = &#123;      msg: &#x27;&#x27;,    &#125;    // 模拟 Vue 实例    let vm = &#123;&#125;    // 对 vm 的 msg 进行数据劫持    Object.defineProperty(vm, &#x27;msg&#x27;, &#123;      // 获取数据      get() &#123;        return data.msg      &#125;,      // 设置 msg      set(newValue) &#123;        // 如果传入的值相等就不用修改        if (newValue === data.msg) return        // 修改数据        data.msg = newValue        document.querySelector(&#x27;#app&#x27;).textContent = data.msg      &#125;,    &#125;)    // 这样子就调用了 defineProperty vm.msg 的 set    vm.msg = &#x27;1234&#x27;  &lt;/script&gt;&lt;/body&gt;\n看了上面的方法只能修改一个属性，实际上我们 data 中数据不可能只有一个,我们何不定义一个方法把data中的数据进行遍历都修改成响应式\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\t&lt;script&gt;        // 模拟 Vue的data        let data = &#123;            msg: &#x27;哈哈&#x27;,            age: &#x27;18&#x27;,        &#125;        // 模拟 Vue 实例        let vm = &#123;&#125;        // 把多个属性转化 响应式        function proxyData() &#123;            // 把data 中每一项都[msg,age] 拿出来操作            Object.keys(data).forEach((key) =&gt; &#123;                // 对 vm 的 属性 进行数据劫持                Object.defineProperty(vm, key, &#123;                    // 可枚举                    enumerable: true,                    // 可配置                    configurable: true,                    // 获取数据                    get() &#123;                        return data[key]                    &#125;,                    // 设置 属性值                    set(newValue) &#123;                        // 如果传入的值相等就不用修改                        if (newValue === data[key]) return                        // 修改数据                        data[key] = newValue                        document.querySelector(&#x27;#app&#x27;).textContent = data[key]                    &#125;,                &#125;)            &#125;)        &#125;        // 调用方法        proxyData(data)\t&lt;/script&gt;&lt;/body&gt;\n发布订阅模式首先来说简单介绍下 一共有三个角色发布者、 订阅者、 信号中心在Vue 中的例子 就是EventBus $on $emit\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;    class Vue &#123;      constructor() &#123;        // 用来存储事件        // 存储的 例子 this.subs = &#123; &#x27;myclick&#x27;: [fn1, fn2, fn3] ,&#x27;inputchange&#x27;: [fn1, fn2] &#125;        this.subs = &#123;&#125;      &#125;      // 实现 $on 方法 type是任务队列的类型 ,fn是方法      $on(type, fn) &#123;        // 判断在 subs是否有当前类型的 方法队列存在        if (!this.subs[type]) &#123;          // 没有就新增一个 默认为空数组          this.subs[type] = []        &#125;        // 把方法加到该类型中        this.subs[type].push(fn)      &#125;      // 实现 $emit 方法      $emit(type) &#123;        // 首先得判断该方法是否存在        if (this.subs[type]) &#123;          // 获取到参数          const args = Array.prototype.slice.call(arguments, 1)          // 循环队列调用 fn          this.subs[type].forEach((fn) =&gt; fn(...args))        &#125;      &#125;    &#125;    // 使用    const eventHub = new Vue()    // 使用 $on 添加一个 sum 类型的 方法到 subs[&#x27;sum&#x27;]中    eventHub.$on(&#x27;sum&#x27;, function () &#123;      let count = [...arguments].reduce((x, y) =&gt; x + y)      console.log(count)    &#125;)    // 触发 sum 方法    eventHub.$emit(&#x27;sum&#x27;, 1, 2, 4, 5, 6, 7, 8, 9, 10)  &lt;/script&gt;&lt;/body&gt;\n观察者模式与发布订阅者不同 观察者中 发布者和订阅者(观察者)是相互依赖的 必须要求观察者订阅内容改变事件 ，而发布订阅者是由调度中心进行调度，那么观察者模式是相互依赖，下面就举个简单例子\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 目标    class Subject &#123;      constructor() &#123;        this.observerLists = []      &#125;      // 添加观察者      addObs(obs) &#123;        // 判断观察者是否有 和 存在更新订阅的方法        if (obs &amp;&amp; obs.update) &#123;          // 添加到观察者列表中          this.observerLists.push(obs)        &#125;      &#125;      // 通知观察者      notify() &#123;        this.observerLists.forEach((obs) =&gt; &#123;          // 每个观察者收到通知后 会更新事件          obs.update()        &#125;)      &#125;      // 清空观察者      empty() &#123;        this.subs = []      &#125;    &#125;    class Observer &#123;      // 定义观察者内容更新事件      update() &#123;        // 在更新事件要处理的逻辑        console.log(&#x27;目标更新了&#x27;)      &#125;    &#125;    // 使用    // 创建目标    let sub = new Subject()    // 创建观察者    let obs1 = new Observer()    let obs2 = new Observer()    // 把观察者添加到列表中    sub.addObs(obs1)    sub.addObs(obs2)    // 目标开启了通知 每个观察者者都会自己触发 update 更新事件    sub.notify()  &lt;/script&gt;&lt;/body&gt;\n鞭尸supershopsendShopCar() &#123;\t\t\t\tlet that = this\t\t\t\tlet arr = []\t\t\t\tthis.tabbar.forEach(item =&gt; &#123;\t\t\t\t\tconsole.log(item);\t\t\t\t\titem.list.forEach(item1 =&gt; &#123;\t\t\t\t\t\tif (item1.num &gt; 0) &#123;\t\t\t\t\t\t\tarr.push(item1)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;)\t\t\t\t&#125;)  \t\t\t\tthis.$store.state.Cartlist = arr\t    \t\t\tconsole.log(arr);\t\t\t\tuni.request(&#123;\t\t\t\t\turl: `https://mall.wuhanzhuangxiu01.cn/apip/cart/`,\t\t\t\t\tmethod: &quot;POST&quot;,\t\t\t\t\tdata: &#123;\t\t\t\t\t\t&quot;data&quot;: JSON.stringify(arr),\t\t\t\t\t\t&quot;appid&quot;: that.appId,\t\t\t\t\t\t&quot;openid&quot;: that.openid,\t\t\t\t\t\t&quot;shopid&quot;: that.shop_info.uid\t\t\t\t\t&#125;,\t\t\t\t\tsuccess: (res) =&gt; &#123;\t\t\t\t\t\tconsole.log(res);\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;,\n关于为什么在shopCarts页面没有实现响应式的原因新加入的Cartlist属性是直接显示在控制台上的，并没有被匹配一对getter和setter，这就是视图不能立即响应的原因。直接给state里的数据使用最简单粗暴的赋值的方式添加属性，并没有通过Vue对数据进行操作，所以这样并不会是响应式。我们需要使用Vue.set(target,propertyName,value)这个方法来实现修改响应式数据\n\ntarget:要更改的数据（一般是响应式对象） 例：state.data\nproperty:这个对象中的子对象或者属性\nvalue：你想要赋的值Vue.set(this.$store.state.Cartlist,&quot;Cartlist&quot;,arr)\n\n","categories":["前端"],"tags":["js"]},{"title":"从promise到async","url":"/2022/08/14/%E4%BB%8Epromise%E5%88%B0async/","content":"JS是一项单线程语言，所有的任务都会在一条线程上执行，但是一些高消耗的操作会堵塞线程。因此JS有同步模式和异步模式。首先宏任务是由node&amp;浏览器主动发起的，而微任务是JS本身发起的宏任务：setTimeout，setInterval，script（整体代码块）微任务：promise.the……,nexttick\n宏任务与微任务在eventloop中的执行顺序简单来说第一个宏任务执行，如果微任务队列存在，则将所有的微任务执行完再继续执行下一个宏任务，直到所有的宏任务执行完毕。\npromisepromise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。在异步任务中，最常见的就是请求嵌套，但小程序的requset请求。\nuni.requset(&#123;  url:&#x27;&#x27;,  success()&#123;    uni.requset(&#123;      url:&#x27;&#x27;,      success()&#123;        uni.requset(&#123;          url:&#x27;&#x27;,          success()&#123;                      &#125;        &#125;)      &#125;    &#125;)  &#125;&#125;)\n这样代码易读性就很烂，就算拆出来单独调用也会增加重复的代码量。（但无所谓）那么promise能干什么呢promise是用来解决两个问题的：\n\n回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象\npromise可以支持多个并发的请求，获取并发请求中的数据\n\nPromise的使用Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\nlet p = new Promise((resolve, reject) =&gt; &#123;    //做一些异步操作    setTimeout(() =&gt; &#123;        console.log(&#x27;执行完成&#x27;);        resolve(&#x27;我是成功！！&#x27;);    &#125;, 2000);&#125;);\nPromise {}\n\nproto: Promise\n[[PromiseState]]: “pending”\n[[PromiseResult]]\n\n在promise的原型上，我们可以看见他有以下的结构，以及现在的状态，promiseState。\n\ncatch: ƒ catch()\nconstructor: ƒ Promise()\nfinally: ƒ finally()\nthen: ƒ then()\n\n_但我们只需要看_constructor上的东西就行了\n\n**all: **_ƒ all()_\n\n谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象\nallSettled: ƒ allSettled()\nany: ƒ any()\narguments: (…)\ncaller: (…)\nlength: 1\nname: “Promise”\nnv_length: (…)\nprototype: Promise {Symbol(Symbol.toStringTag): “Promise”, constructor: ƒ, then: ƒ, catch: ƒ, finally: ƒ}\n**race: **_ƒ race()_\n\n谁跑的快，以谁为准执行回调\n**reject: **_ƒ reject()_\n\n把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。then和catch都能捕捉到失败的回调，只不过catch大部分时候是抛出异常让后面的代码继续执行的情况才会使用。\n\n**resolve: **_ƒ resolve()_\nSymbol(Symbol.hasInstance): ƒ value(e)\nSymbol(Symbol.species): (…)\nget Symbol(Symbol.species): ƒ Symbol.species\n\nthen的链式调用\nlet p = new Promise(function()&#123;    resolve(&#x27;我是成功&#x27;);&#125;)p.then((data) =&gt; &#123;console.log(data);&#125;,(err) =&gt; &#123;&#125;);p.then((data) =&gt; &#123;console.log(data);&#125;,(err) =&gt; &#123;&#125;);p.then((data) =&gt; &#123;console.log(data);&#125;,(err) =&gt; &#123;&#125;);\n扩展写法\nthen(onFulFilled, onRejected) &#123;  if (this.status === &#x27;resolved&#x27;) &#123;    onFulFilled(this.value);  &#125;  if (this.status === &#x27;rejected&#x27;) &#123;    onRejected(this.reason);  &#125;  // 当前既没有完成 也没有失败  if (this.status === &#x27;pending&#x27;) &#123;    // 存放成功的回调    this.onResolvedCallbacks.push(() =&gt; &#123;      onFulFilled(this.value);    &#125;);    // 存放失败的回调    this.onRejectedCallbacks.push(() =&gt; &#123;      onRejected(this.reason);    &#125;);  &#125;&#125;\n那么在知道了这些情况之后那么我们就可以把请求变成微任务来调用以达成我们需要的异步变同步。\nnew Promise((resolve,reject)=&gt;&#123;    uni.request(&#123;      url: ,      data:,      method: ,      header:header,      complete:(res)=&gt;&#123;          console.log(`耗时$&#123;Date.now() - timeStart&#125;`);          if(res.statusCode ==200)&#123;//请求成功            resolve(res.data)          &#125;else&#123;            reject(res);          &#125;      &#125;    &#125;)//暴露出去\n//如果在页面中需要发起多个需要同步的请求，那么Promise.all([  api.get(&#x27;param1&#x27;),  api.get(&#x27;param2&#x27;)]).then(result =&gt; &#123;  console.log(result)&#125;).catch(e =&gt; &#123;  console.log(e)&#125;)\nasync awaitasync 函数是 Generator 函数的语法糖,但暂时可以先不管Generator 是什么。\nfunction req()&#123;  uni.request(...)&#125;\nPromise 的方式虽然解决了 callback hell，但是这种方式充满了 Promise的 then() 方法，如果处理流程复杂的话，整段代码将充满 then。语义化不明显，代码流程不能很好的表示执行流程。（主要是写起来麻烦）\nconst delay = timeout =&gt; new Promise(resolve=&gt; setTimeout(resolve, timeout));async function f()&#123;    await delay(1000);    await delay(2000);    await delay(3000);    return &#x27;done&#x27;;&#125;f().then(v =&gt; console.log(v)); // 等待6s后才输出 &#x27;done&#x27;\n我们来模拟一下请求，那么在三个请求发完之后，我们才会继续执行，来达成异步。用法就是这么简单，但是如何来处理错误呢。\nconst delay = timeout =&gt; new Promise(resolve=&gt; setTimeout(resolve, timeout));async function f()&#123;    await delay(1000);    await delay(2000);    await Promise.reject(&#x27;error&#x27;);    await delay(3000);    return &#x27;done&#x27;;&#125;f().then(v =&gt; console.log(v)); // 等待3s后才输出 &#x27;error&#x27; \n当 async 函数中只要一个 await 出现 reject 状态，则后面的 await 都不会被执行。\nconst delay = timeout =&gt; new Promise(resolve=&gt; setTimeout(resolve, timeout));async function f()&#123;    await delay(1000);    await delay(2000);    try &#123;        await Promise.reject(&#x27;error&#x27;)    &#125; catch (error) &#123;        console.log(error);    &#125;    await delay(3000);    return &#x27;done&#x27;;&#125;f().then(v =&gt; console.log(v)); // 等待6s后才输出 &#x27;error&#x27; \n","categories":["前端"],"tags":["js"]},{"title":"全局开启分享代码封装","url":"/2022/12/12/%E5%85%A8%E5%B1%80%E5%BC%80%E5%90%AF%E5%88%86%E4%BA%AB%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85/","content":"export default &#123;\tdata() &#123;\t\treturn &#123;\t\t\t//设置默认的分享参数\t\t\t//如果页面不设置share，就触发这个默认的分享\t\t\tshare: &#123;\t\t\t\ttitle: &#x27;翻译小程序&#x27;,\t\t\t\tpath: `/pages/index/index`,  //默认跳转首页\t\t\t\timageUrl: &#x27;&#x27;,  //可设置默认分享图，不设置默认截取头部5:4\t\t\t&#125;\t\t&#125;\t&#125;,\tonShareAppMessage(res) &#123; //发送给朋友\t\treturn &#123;\t\t\ttitle: this.share.title,\t\t\tpath: this.share.path,\t\t\timageUrl: this.share.imageUrl,\t\t\tsuccess(res) &#123;\t\t\t\tconsole.log(&#x27;success(res)==&#x27;, res);\t\t\t\tuni.showToast(&#123;\t\t\t\t\ttitle: &#x27;分享成功&#x27;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tfail(res) &#123;\t\t\t\tconsole.log(&#x27;fail(res)==&#x27;, res);\t\t\t\tuni.showToast(&#123;\t\t\t\t\ttitle: &#x27;分享失败&#x27;,\t\t\t\t\ticon: &#x27;none&#x27;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;,\tonShareTimeline(res) &#123; //分享到朋友圈\t\treturn &#123;\t\t\ttitle: this.share.title,\t\t\tpath: this.share.path,\t\t\timageUrl: this.share.imageUrl,\t\t\tsuccess(res) &#123;\t\t\t\tconsole.log(&#x27;success(res)==&#x27;, res);\t\t\t\tuni.showToast(&#123;\t\t\t\t\ttitle: &#x27;分享成功&#x27;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tfail(res) &#123;\t\t\t\tconsole.log(&#x27;fail(res)==&#x27;, res);\t\t\t\tuni.showToast(&#123;\t\t\t\t\ttitle: &#x27;分享失败&#x27;,\t\t\t\t\ticon: &#x27;none&#x27;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;,&#125;\n\n","categories":["前端"],"tags":["小程序"]},{"title":"兼职信息aes rsa加密及websocket简易聊天实现","url":"/2022/11/25/%E5%85%BC%E8%81%8C%E4%BF%A1%E6%81%AFaes%20rsa%E5%8A%A0%E5%AF%86%E5%8F%8Awebsocket%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%9E%E7%8E%B0/","content":"AES加密解密\nconst CryptoJS = require(&#x27;crypto-js&#x27;)// const keyStr = &#x27;encode@3#!8^k.j$&#x27;// const ivStr = &#x27;vector@3#!8^k.j$&#x27;// const txt = &#x27;123&#x27;export function encrypt(data, keyS, ivS) &#123;  // let key = keyS || keyStr  // let iv = ivS || ivStr  console.log(data,&quot;data&quot;);  console.log(keyS,&quot;keyS&quot;);  console.log(ivS,&quot;ivS&quot;); var key = CryptoJS.enc.Utf8.parse(keyS) var iv = CryptoJS.enc.Utf8.parse(ivS)  const src = CryptoJS.enc.Utf8.parse(data)  const cipher = CryptoJS.AES.encrypt(src, key, &#123;    iv: iv, // 初始向量    mode: CryptoJS.mode.CBC, // 加密模式    padding: CryptoJS.pad.Pkcs7, // 填充方式  &#125;)  const encrypted = cipher.toString()  console.log(encrypted,&#x27;encrypted&#x27;);  return encrypted&#125;export function decrypt(data, keyS, ivS) &#123;  // let key = keyS || keyStr  // let iv = ivS || ivStr var key = CryptoJS.enc.Utf8.parse(keyS) var iv = CryptoJS.enc.Utf8.parse(ivS)  const cipher = CryptoJS.AES.decrypt(data, key, &#123;    iv: iv,    mode: CryptoJS.mode.CBC,    padding: CryptoJS.pad.Pkcs7,  &#125;)  const decrypted = cipher.toString(CryptoJS.enc.Utf8) // 返回的是加密之前的原始数据-&gt;字符串类型  console.log(cipher,&quot;000&quot;);  return decrypted&#125;\n加密:encrypt(数据,密钥,偏移量)解密:decrypt(数据,密钥,偏移量)\nrsa加密解密1.npm i wxmp-rsa -S2.import WxmpRsa from ‘wxmp-rsa’3.实例化rsaconst rsa &#x3D; new WxmpRsa()4.定义公钥const publicKey &#x3D;   -----BEGIN PUBLIC KEY-----   MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgFnWSUwsmGawhMJ30z6y5li2jcf1   m7rPMZcwZOS3To8bk3OBaMGhVEc1F8GtJBbc1rn/HCLNL9zrCy21EefJON8tRFcY   HnpseZSzh+349lIhS+MFw9x4JUddwSPDyxwha929cKzMuVoftu3CJ+kqDBVvxLk7   iDBzUMqW3Kgehk2TAgMBAAE=   -----END PUBLIC KEY----- 5.设置公钥rsa.setPublicKey(publicKey)6.加密const cryptStr &#x3D; rsa.encryptLong(str)console.log(‘加密后的结果：’, cryptStr)7.&#x2F;&#x2F; 定义私钥const privateKey &#x3D; -----BEGIN RSA PRIVATE KEY----- MIICWgIBAAKBgFnWSUwsmGawhMJ30z6y5li2jcf1m7rPMZcwZOS3To8bk3OBaMGh VEc1F8GtJBbc1rn/HCLNL9zrCy21EefJON8tRFcYHnpseZSzh+349lIhS+MFw9x4 JUddwSPDyxwha929cKzMuVoftu3CJ+kqDBVvxLk7iDBzUMqW3Kgehk2TAgMBAAEC gYBRChPeyk/EOrHX912xLpLKLguh+LY9g1B50ScChzUvtTGDPZaxLQYoogVHKhfn I9nzuOS5pBzsDX9tAO0hCQzqfHgqRjn+vEgm1Ui+f0E3BVRnhobcJKZpZqlvCBR5 Gu2+zlrY4SeGq3AuQSr/A5FiB5k0RgsvNycDTjqyg7TXGQJBAJoZ8Yr0zakxT1I8 lVqsFbeNPtt8FNG2UgIlIs9RL7aXhw+Y3sWtk/kbaOXafSofu0NcQYx4Km3M3kiP lcNfTJ8CQQCVPcaRpu+mprRgHS6s76Z668NaFsjX04CUUa0kCrey+Nf/SJJ3BkRH M7GllZWuI/RSXs/F5N38p5bfkn7QZqaNAkBy3dHJZW8DpgjdYOFnhAxwFK39BwGx zHhWtv26kWbCcTKwsp+jtB4vunm3k+RmiN6aeGM35L6jt+kdJ0JYLmo7AkBJpRZb wZj5D8Jqu3vQ8uGgPr9DsYKinkgQ6M0bv/4uXwWXf+Rmv7zpteSv5UTbjfp+uzKk YO/6QWj+InhZto3xAkAOA0i702dLHm5elLWvht7UEYIDEW1+rYGdbthmJBvT9sZh VKL954Y9hDzBWepjYsBiJnmIkgeladPnU5025/G/ -----END RSA PRIVATE KEY-----8. 设置私钥rsa.setPrivateKey(privateKey)9. 解密const originalStr &#x3D; rsa.decryptLong(cryptStr)console.log(‘解密后的原始数据：’, originalStr)\nWebSocket 是什么？WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\n为什么需要 WebSocket ？了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求&#x2F;响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n客户端 API以下 API 用于创建 WebSocket 对象。\nvar Socket = new WebSocket(url, [protocol] );\nWebSocket 的属性\nWebSocket 的事件\nWebSocket 的方法\nWebSocket 连接demo// 初始化一个 WebSocket 对象var ws = new WebSocket(&#x27;ws://localhost:9998/echo&#x27;);// 建立 web socket 连接成功触发事件ws.onopen = function() &#123;  // 使用 send() 方法发送数据  ws.send(&#x27;发送数据&#x27;);  alert(&#x27;数据发送中...&#x27;);&#125;;// 接收服务端数据时触发事件ws.onmessage = function(evt) &#123;  var received_msg = evt.data;  alert(&#x27;数据已接收...&#x27;);&#125;;// 断开 web socket 连接成功触发事件ws.onclose = function() &#123;  alert(&#x27;连接已关闭...&#x27;);&#125;;\n兼职聊天页面WebSocket 连接步骤1.全局定义websocket对象2.建立webscoket连接\nsocketTaskRoom = wx.connectSocket(&#123;  url: `wss://mall.wuhanzhuangxiu01.cn/job_ws/chat/$&#123;that.$store.state.openid&#125;__$&#123;that.jobDetailObj.openid&#125;/?_=$&#123;time&#125;&amp;dds=$&#123;postData&#125;&amp;rk=$&#123;that.key&#125;`,  success: (res) =&gt; &#123;    console.log(res);  &#125;&#125;);\n连接url动态生成，当前用户openid___被连接用户openid + 时间戳 +dds + rkdds &#x3D; postdata; rk &#x3D; keykey &#x3D; rsa加密（时间戳+三位随机字符串）\nurlData = `user_id=$&#123;that.$store.state.openid&#125;&amp;username=$&#123;that.$store.state.user_name&#125;&amp;chat_with_id=$&#123;that.jobDetailObj.openid&#125;&amp;chat_with_name=$&#123;that.jobDetailObj.username&#125;&amp;chat_job_id=$&#123;that.jobDetailObj.id&#125;&amp;chat_job_title=$&#123;that.jobDetailObj.title&#125;&amp;appid=$&#123;that.$store.state.appid&#125;&amp;avatar=$&#123;that.$store.state.user_img&#125;&amp;chat_with_avatar=$&#123;that.jobDetailObj.headimg&#125;`postData = encrypt(urlData,time+randomStr,this.iv)\niv &#x3D; MD5加密（时间戳）.substr(8,16)\nsocketTaskRoom.onOpen(function (res) &#123;\t\t\t\t\t  console.log(&#x27;WebSocket连接已打开！&#x27;);\t\t\t\t\t  socketOpen = true\t\t\t\t\t&#125;);\t\t\t\t\tsocketTaskRoom.onError(function (res) &#123;\t\t\t\t\t  console.log(&#x27;WebSocket连接打开失败，请检查！&#x27;);\t\t\t\t\t  socketOpen = false\t\t\t\t\t&#125;);\t\t\t\t\tsocketTaskRoom.onMessage(function(res) &#123;\t\t\t\t\t\tconsole.log(&#x27;收到服务器内容：&#x27; + res.data);\t\t\t\t\t\tthat.getSocketMsg(res.data); // 监听到有新服务器消息\t\t\t\t\t\tthat.talkList.push(JSON.parse(res.data))\t\t\t\t\t\t\t\t\t\t&#125;)\t\t\t\t\tsocketTaskRoom.onClose(function (res) &#123;\t\t\t\t\t  console.log(&#x27;WebSocket 已关闭！&#x27;);\t\t\t\t\t&#125;);\n所有数据处理完成后，连接成功，通过onopen方法监听到连接成功消息，通过onMessage收到服务端推送的消息，拿到消息后json parse push进聊天列表（此时消息都是新的聊天内容）本地通过send方法发送消息\nlet obj = &#123;send_user_id: that.$store.state.openid, send_username: that.$store.state.user_name, send_time: &quot;2022-10-13 11:40:00&quot;, send_message: &quot;我是user1&quot;, chat_with_id: that.oid, chat_with_name: that.jobDetailObj.username,chat_job_id:that.jobDetailObj.id,chat_job_title:that.jobDetailObj.title,appid:that.$store.state.appid,avatar:that.$store.state.user_img,chat_with_avatar:that.jobDetailObj.headimg&#125;socketTaskRoom.send(&#123;\t\t\t\t\t\tdata: JSON.stringify(obj),\t\t\t\t\t\tsuccess: (res) =&gt; &#123;\t\t\t\t\t\t\tconsole.log(res);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;);\n消息发送成功后，onMessage可以监听到服务端返回的消息列表，即你此时发送成功的消息。\n// 发送信息\t\t\tsend()&#123;\t\t\t\tif(!this.content)&#123;\t\t\t\t\tuni.showToast(&#123;\t\t\t\t\t\ttitle:&#x27;请输入有效的内容&#x27;,\t\t\t\t\t\ticon:&#x27;none&#x27;\t\t\t\t\t&#125;)\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\tuni.showLoading(&#123;\t\t\t\t\ttitle:&#x27;正在发送&#x27;\t\t\t\t&#125;)\t\t\t\tsetTimeout(()=&gt;&#123;\t\t\t\t\tuni.hideLoading();\t\t\t\t\tthis.sendMessage()\t\t\t\t\tthis.$nextTick(()=&gt;&#123;\t\t\t\t\t\t// 清空内容框中的内容\t\t\t\t\t\tthis.content = &#x27;&#x27;;\t\t\t\t\t\tuni.pageScrollTo(&#123;\t\t\t\t\t\t    scrollTop: 999999,\t// 设置一个超大值，以保证滚动条滚动到底部\t\t\t\t\t\t    duration: 0\t\t\t\t\t\t&#125;);\t\t\t\t\t&#125;)\t\t\t\t&#125;,500);\t\t\t&#125;,\n聊天历史记录获取getHistory()&#123;\t\t\t\tlet that = this\t\t\t\tconsole.log(that.jobDetailObj,&quot;1111111&quot;);\t\t\t\tuni.request(&#123;\t\t\t\t\turl:`https://mall.wuhanzhuangxiu01.cn/job_chat/ch`,\t\t\t\t\tdata:&#123;\t\t\t\t\t\t&quot;user_id&quot;:that.$store.state.openid,\t\t\t\t\t\t&quot;chat_with_id&quot;:that.type==2?that.oid:that.jobDetailObj.openid,\t\t\t\t\t\t&quot;appid&quot;:that.$store.state.appid\t\t\t\t\t&#125;,\t\t\t\t\tmethod:&quot;POST&quot;,\t\t\t\t\tsuccess: (res) =&gt; &#123;\t\t\t\t\t\tlet jsonData = decrypt(res.data.data,&quot;2031618372682131&quot;,&quot;9329859705602774&quot;)\t\t\t\t\t\t// console.log(res.data.data);\t\t\t\t\t\tconsole.log(jsonData,&quot;解密后&quot;);\t\t\t\t\t\tthat.hideLoadTips(true);\t\t\t\t\t\tthat.talkList = JSON.parse(jsonData)\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;,\n聊天列表界面websocketgetChatList()&#123;\t\t\t\tlet that = this\t\t\t\tsocketTaskList = wx.connectSocket(&#123;\t\t\t\t  url: &#x27;wss://mall.wuhanzhuangxiu01.cn/job_ws/chatList/&#x27;\t\t\t\t&#125;);\t\t\t\tsocketTaskList.onOpen(function (res) &#123;\t\t\t\t  console.log(&#x27;WebSocket连接已打开！&#x27;);\t\t\t\t  that.btn()\t\t\t\t  socketOpen = true\t\t\t\t&#125;);\t\t\t\tsocketTaskList.onError(function (res) &#123;\t\t\t\t  console.log(&#x27;WebSocket连接打开失败，请检查！&#x27;);\t\t\t\t  socketOpen = false\t\t\t\t&#125;);\t\t\t\tsocketTaskList.onMessage(function(res) &#123;\t\t\t\t\tconsole.log(&#x27;收到服务器内容：&#x27; + res.data);\t\t\t\t\tlet data = decrypt(res.data,&#x27;1189789282863375&#x27;,&#x27;5671714989170848&#x27;)\t\t\t\t\tconsole.log(JSON.parse(data));\t\t\t\t\tthat.list = JSON.parse(data)\t\t\t\t\t\t\t\t&#125;)\t\t\t\tsocketTaskList.onClose(function (res) &#123;\t\t\t\t  console.log(&#x27;WebSocket 已关闭！&#x27;);\t\t\t\t&#125;);\t\t\t&#125;,\n页面跳转时断开连接socketTaskList.close()\nwebsocket重连机制checkOpenSocket() &#123;\t\t\t\tsocketTaskRoom.send(&#123;\t\t\t\t\tdata: &#x27;ping&#x27;,\t\t\t\t\tsuccess: res =&gt; &#123;\t\t\t\t\t\tconsole.log(res);\t\t\t\t\t\treturn;\t\t\t\t\t&#125;,\t\t\t\t\tfail: err =&gt; &#123;\t\t\t\t\t\t// 未连接打开websocket连接\t\t\t\t\t\tthis.lianJie()\t\t\t\t\t&#125;\t\t\t\t&#125;);\t\t\t&#125;,// 检测心跳reset  在监听到服务端消息时调用\t\t\treset() &#123;    \t\t\t\tclearInterval(this.timeoutObj);\t\t\t\tthis.start(); // 启动心跳\t\t\t&#125;,\t\t\t// 启动心跳 start\t\t\tstart() &#123;\t\t\t\tlet that = this\t\t\t\tthis.timeoutObj = setInterval(function() &#123;\t\t\t\t\tsocketTaskRoom.send(&#123;\t\t\t\t\t\tdata: &#x27;ping&#x27;,\t\t\t\t\t\tsuccess: res =&gt; &#123;\t\t\t\t\t\t\tconsole.log(res);\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;,\t\t\t\t\t\tfail: err =&gt; &#123;\t\t\t\t\t\t\tconsole.log(&#x27;连接失败重新连接....&#x27;);\t\t\t\t\t\t\t// that.addKey();\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;);\t\t\t\t&#125;, this.timeout);\t\t\t&#125;,\n\n","categories":["前端"],"tags":["js"]},{"title":"大小缩放轮播","url":"/2022/05/05/%E5%A4%A7%E5%B0%8F%E7%BC%A9%E6%94%BE%E8%BD%AE%E6%92%AD/","content":"&lt;template&gt;\t&lt;block&gt;\t\t&lt;swiper class=&quot;swiper-block&quot; :autoplay=&quot;false&quot; :circular=&quot;true&quot; previous-margin=&quot;90rpx&quot; next-margin=&quot;90rpx&quot;\t\t\tcurrent=&quot;0&quot; @change=&quot;swiperChange&quot;&gt;\t\t\t&lt;block v-for=&quot;(item, index) in swiperImgUrls&quot; :key=&quot;index&quot;&gt;\t\t\t\t&lt;swiper-item class=&quot;swiper-item&quot;&gt;\t\t\t\t\t&lt;image mode=&quot;aspectFill&quot; :src=&quot;item&quot;\t\t\t\t\t\t:class=&quot;&#x27;slide-image &#x27; + (swiperIndex == index ? &#x27;active&#x27; : &#x27;&#x27;)&quot; /&gt;\t\t\t\t&lt;/swiper-item&gt;\t\t\t&lt;/block&gt;\t\t&lt;/swiper&gt;\t&lt;/block&gt;&lt;/template&gt;&lt;script&gt;\t// index.js\t// 获取应用实例\tconst app = getApp();\texport default &#123;\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tswiperImgUrls: [\t\t\t\t\t&#x27;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f184e7c3-1912-41b2-b81f-435d1b37c7b4/1ae87107-2943-4ba6-be2b-390ca27c6260.png&#x27;,\t\t\t\t\t&#x27;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f184e7c3-1912-41b2-b81f-435d1b37c7b4/1ae87107-2943-4ba6-be2b-390ca27c6260.png&#x27;,\t\t\t\t\t&#x27;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f184e7c3-1912-41b2-b81f-435d1b37c7b4/1ae87107-2943-4ba6-be2b-390ca27c6260.png&#x27;\t\t\t\t],\t\t\t\tswiperIndex: 0\t\t\t&#125;;\t\t&#125;,\t\tonLoad: function(options) &#123;&#125;,\t\tmethods: &#123;\t\t\tswiperChange(e) &#123;\t\t\t\tconst that = this;\t\t\t\tthat.swiperIndex = e.detail.current\t\t\t&#125;\t\t&#125;\t&#125;;&lt;/script&gt;&lt;style&gt;\t.swiper-block &#123;\t\theight: 300rpx;\t\twidth: 100%;\t&#125;\t.swiper-item &#123;\t\tdisplay: flex;\t\tflex-direction: column;\t\tjustify-content: center;\t\talign-items: flex-start;\t\toverflow: unset;\t&#125;\t.slide-image &#123;\t\theight: 250rpx;\t\twidth: 520rpx;\t\tborder-radius: 9rpx;\t\tbox-shadow: 0px 0px 30rpx rgba(0, 0, 0, 0.2);\t\tmargin: 0rpx 30rpx;\t\tz-index: 1;\t&#125;\t.active &#123;\t\ttransform: scale(1.14);\t\ttransition: all 0.2s ease-in 0s;\t\tz-index: 20;\t&#125;&lt;/style&gt;\n","categories":["前端"],"tags":["vue"]},{"title":"小程序echarts动态渲染过程","url":"/2022/08/11/%E5%B0%8F%E7%A8%8B%E5%BA%8Fecharts%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","content":"1.请求的数据先行（request保存数据没什么好说的）2.在最外层定义charts实例为空，ec绑定data外方法\n&lt;ec-canvas id=&quot;mychart-dom-pie&quot; class=&quot;ech1&quot; canvas-id=&quot;mychart-pie&quot; ec=&quot;&#123;&#123; ec &#125;&#125;&quot;&gt;&lt;/ec-canvas&gt;\n记得给高度\nvar Charts1 = null;const app = getApp();Page(&#123;  data&#123;    ec:&#123;        onInit:initChart1      &#125;  &#125;&#125;)function initChart1(canvas, width, height, dpr) &#123;  const chart = echarts.init(canvas, null, &#123;    width: width,    height: height,    devicePixelRatio: dpr // new  &#125;);  canvas.setChart(chart);  return chart;\n3.定义一个方法来获取return需要渲染的数据\ngetOption1()&#123;   var option1 = &#123;     backgroundColor: &quot;#ffffff&quot;,     title: &#123;       subtext: &#x27;下拉刷新获取最新数据&#x27;     &#125;,     series: [&#123;       label: &#123;         normal: &#123;           fontSize: 14         &#125;       &#125;,       type: &#x27;pie&#x27;,       center: [&#x27;50%&#x27;, &#x27;50%&#x27;],       radius: [&#x27;35%&#x27;, &#x27;55%&#x27;],       data: app.globalData.pie,       emphasis: &#123;         itemStyle: &#123;           shadowBlur: 10,           shadowOffsetX: 0,           shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;         &#125;       &#125;     &#125;]   &#125;;   return option1 &#125;\n4.接下来初始化数据，初始化数据和第二次渲染方法分开写，在进入页面时在onload中获取echarts的id\nthis.echartsComponnet1 = this.selectComponent(&#x27;#mychart-dom-pie&#x27;);\ninit_echarts1: function () &#123;  this.echartsComponnet1.init((canvas, width, height) =&gt; &#123;    // 初始化图表    const Chart = echarts.init(canvas, null, &#123;      width: width,      height: height    &#125;);    this.setOption1(Chart)    // 注意这里一定要返回 chart 实例，否则会影响事件处理等    return Chart;  &#125;);&#125;\nsetOption1: function (Chart1) &#123;    Chart1.clear(); // 清除    Chart1.setOption(this.getOption1()); //获取新数据 &#125;\n5.动态加载时调用二次加载图标的方法就行\n","categories":["前端"],"tags":["小程序"]},{"title":"巨焰小程序接入订阅消息","url":"/2022/12/02/%E5%B7%A8%E7%84%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF/","content":"巨焰小程序接入订阅消息页面 index.js\ndata: &#123;\tcode: &#x27;&#x27;,\t\ttemplateid: &#x27;&#x27;,\t\t\tappid:&#x27;&#x27;,\t\t\t\topenid:&#x27;&#x27;&#125;,\t\tonLoad()&#123;\t\tlet that = this\t\t//开始获取code\t\tthat.onCode()\t\t//三秒后弹窗让用户订阅\t\tsetTimeout(() =&gt; &#123;\t\t\twx.showModal(&#123;\t\t\t\ttitle: &#x27;提示&#x27;,\t\t\t\tcontent: &#x27;是否订阅XXXX消息&#x27;,\t\t\t\tsuccess(res) &#123;\t\t\t\t\tif (res.confirm) &#123;\t\t\t\t\t\tconsole.log(&#x27;用户点击确定&#x27;)\t\t\t\t\t\tthat.onTake()\t\t\t\t\t&#125; else if (res.cancel) &#123;\t\t\t\t\t\tconsole.log(&#x27;用户点击取消&#x27;)\t\t\t\t\t\tthat.onTake()\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;)\t\t&#125;, 3000)\t&#125;//获取codeonCode() &#123;\tconsole.log(&#x27;开始获取Code&#x27;);\tlet that = this\twx.login(&#123;\t\ttimeout: 10000,\t\tsuccess: (res) =&gt; &#123;\t\t\tconsole.log(res);\t\t\tthat.setData(&#123;\t\t\t\tcode: res.code\t\t\t&#125;)\t\t&#125;,\t&#125;)&#125;,\t// 发起订阅消息\tonTake() &#123;\t\tconsole.log(&#x27;开始订阅&#x27;);\t\tlet that = this\t\tlet accountInfo = wx.getAccountInfoSync();\t\tlet appid = accountInfo.miniProgram.appId;\t\t// 获取模板id\t\twx.request(&#123;\t\t\turl: &#x27;https://newsaas.guangzhouzhuangxiu01.cn/api/xcx/index/xcxsubtemplate&#x27;,\t\t\tdata: &#123;\t\t\t\twxappid: appid\t\t\t&#125;,\t\t\tsuccess(res) &#123;\t\t\t\tconsole.log(res.data[0]);\t\t\t\tthat.setData(&#123;\t\t\t\t\ttemplateid: res.data[0].templateid,\t\t\t\t\tappid,\t\t\t\t&#125;)\t\t\t\twx.requestSubscribeMessage(&#123;\t\t\t\t\ttmplIds: [that.data.templateid],\t\t\t\t\tsuccess(res) &#123;\t\t\t\t\t\tif (res[that.data.templateid] === &#x27;accept&#x27;) &#123;\t\t\t\t\t\t\tconsole.log(&#x27;用户同意了&#x27;)\t\t\t\t\t\t\t// 订阅小程序获取用户openid\t\t\t\t\t\t\twx.request(&#123;\t\t\t\t\t\t\t\turl: &#x27;https://newsaas.guangzhouzhuangxiu01.cn/api/xcx/index/getwxopenid&#x27;,\t\t\t\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\t\t\tname: &#x27;&#x27;,\t\t\t\t\t\t\t\t\tappId: appid,\t\t\t\t\t\t\t\t\tsecret: &#x27;132&#x27;,\t\t\t\t\t\t\t\t\ttmplIds: that.data.templateid,\t\t\t\t\t\t\t\t\tcode: that.data.code\t\t\t\t\t\t\t\t&#125;,\t\t\t\t\t\t\t\tsuccess(res1)&#123;\t\t\t\t\t\t\t\t\tconsole.log(&#x27;订阅完成：&#x27;, res1);\t\t\t\t\t\t\t\t\twx.showToast(&#123;\t\t\t\t\t\t\t\t\t\ttitle: &#x27;订阅OK！&#x27;,\t\t\t\t\t\t\t\t\t\tduration: 1000,\t\t\t\t\t\t\t\t\t&#125;)\t\t\t\t\t\t\t\t\tthat.setData(&#123;\t\t\t\t\t\t\t\t\t\topenid: res1.data.openid\t\t\t\t\t\t\t\t\t&#125;)\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t&#125;)\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;,\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;)  &#125;,\n\n","categories":["前端"],"tags":["小程序"]},{"title":"微信支付详解","url":"/2022/09/25/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%AF%A6%E8%A7%A3/","content":"一．概论\n\nNative支付：\n\n商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式返回说明：微信接口返回 url 链接（wxpay:&#x2F;&#x2F;）   前端根据url生成对应的二维码,用户扫码支付\n\n付款码支付：\n\n用户出示微信钱包中的条码、二维码，商家通过扫描用户条码即可完成收款返回说明：（客户出示微信的条码，商家通过扫码机扫码完成支付）备注：条码扫码机原理：扫码机在扫码时会识别条码里包含的数字+回车键事件（举例：input输入框监听回车键按键事件）\n\nH5支付：\n\n商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。返回支付H5 url链接，用户跳转到url界面去唤醒支付\n\nAPP支付：\n\n商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。在APP内直接通过activity唤醒微信模块内支付模块(每一个APP软件的每一个界面都是一个activity，另一个APP可以通过)\n\n小程序支付:\n\n在微信内打开小程序时，可以调用微信支付完成下单购买的流程微信小程序内调起微信支付接口\n二．详情以下已小程序支付为例说明①V2版本V2版本介绍：（本公司项目目前皆使用的是V2版本）V2版本默认是不需要配置证书的 ，但是配置了证书后必须使用证书方式进行调用接口说明：第一步：（前端小程序功能）小程序调起支付wx.requestPayment(    {        &#x2F;&#x2F;时间戳“timeStamp”: “1414561699”,&#x2F;&#x2F;随机字符串，不长于32位。        “nonceStr”: “5K8264ILTKCH16CQ2502SI8ZNMTM67VS”,         &#x2F;&#x2F;小程序下单接口返回的prepay_id参数值，提交格式如：prepay_id&#x3D;**     &#x2F;&#x2F;该参数由微信支付统一下单接口返回（如附注一）“package”: “prepay_id&#x3D;wx201410272009395522657a690389285100”,&#x2F;&#x2F;签名类型，默认为HMAC256和MD5。        “signType”: “MD5”,         &#x2F;&#x2F;该sign通过加密算法生成        “paySign”: “oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq/xDg&#x3D;&#x3D;”,        “success”:function(res){},        “fail”:function(res){},        “complete”:function(res){}    })附注一：统一下单接口获取prepay_id统一下单接口url：https://api.mch.weixin.qq.com/pay/unifiedorder参数说明：‘appid’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID‘mch_id’ &#x3D;&gt; $this-&gt;mch_id, &#x2F;&#x2F;商户号nonce_str’ &#x3D;&gt; $this-&gt;createNoncestr(), &#x2F;&#x2F;随机字符串‘body’ &#x3D;&gt; $this-&gt;body,‘out_trade_no’ &#x3D;&gt; ‘2018013106125348’, &#x2F;&#x2F;商户订单号‘total_fee’ &#x3D;&gt;100, &#x2F;&#x2F;总金额 单位 分‘spbill_create_ip’ &#x3D;&gt; ‘192.168.0.161’, &#x2F;&#x2F;终端 IP‘notify_url’ &#x3D;&gt;‘’, &#x2F;&#x2F;通知地址  确保外网能正常访问‘openid’ &#x3D;&gt; $this-&gt;openid, &#x2F;&#x2F;用户 id‘trade_type’ &#x3D;&gt; ‘JSAPI’&#x2F;&#x2F;交易类型‘sign’&#x3D;&gt;根据以上参数生成（如果配置了证书：ssl_key_addr：‘’，ssl_cert_addr：‘’ 记得是证书的绝对地址而不是证书里面的内容 v3版本使用的是证书里的内容）备注：①sign的生成算法（注意这个sign并不是小程序所需要的paysign而是统一下单接口需要的sign）将以上参数去掉sign参数后  进行按字典序排序后去掉空格  在转为appid&#x3D;123&amp;mch_id&#x3D;123123&amp;…&amp;trade_type&#x3D;JSAPI形式的字符串str；再在字符串str后拼接key 得到新的字符串str（appid&#x3D;123&amp;mch_id&#x3D;123123&amp;…&amp;trade_type&#x3D;JSAPI&amp;key&#x3D;12312313）最后将得到的str进行md5加密 得到所谓的sign②注意v2版本 提交给微信的并非是我们常见的json形式的数据而是xml格式（xml教程：https://www.w3school.com.cn/xml/index.asp）以上接口成功后会拿到所需要的prepay_id有了prepay_id后  我们就还剩一个参数没有 那便是小程序调起支付所需要的paysign此时需要在根据上面sign的生成算法 根据值生成一个小程序使用的paysign学名把它叫做 二次验签 参数如下 ‘appId’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID ‘timeStamp’ &#x3D;&gt; ‘’ . time() . ‘’, &#x2F;&#x2F;时间戳 ‘nonceStr’ &#x3D;&gt; $this-&gt;createNoncestr(), &#x2F;&#x2F;随机串 ‘package’ &#x3D;&gt; ‘prepay_id&#x3D;’, &#x2F;&#x2F;数据包（上面拿到的prepay_id） ‘signType’ &#x3D;&gt; ‘MD5’&#x2F;&#x2F;签名方式\n到此：小程序所需要的所有参数已经全部获取  直接调用即可拉起微信支付②V3V3接口是最近出来的新的方式，v3的sign生成算法和v2的逻辑上有着本质的区别只要一个一样的  那就是都需要二次验签，具体区别如下图：可以看到  ①v3 已经放弃了你们常见的MD5  而改用最新的RSA+SHA256(俗称RSA2加密方式)②v2的所有返回结果都是明文的xml  v3改成了加密后的json但是需要解密后才能拿到真正的返回值（解密算法AES-256-GCM）具体流程如下：第一步：（前端小程序功能）小程序调起支付wx.requestPayment(    {        &#x2F;&#x2F;时间戳“timeStamp”: “1414561699”,&#x2F;&#x2F;随机字符串，不长于32位。        “nonceStr”: “5K8264ILTKCH16CQ2502SI8ZNMTM67VS”,         &#x2F;&#x2F;小程序下单接口返回的prepay_id参数值，提交格式如：prepay_id&#x3D;***     &#x2F;&#x2F;该参数由微信支付统一下单接口“package”: “prepay_id&#x3D;wx201410272009395522657a690389285100”,&#x2F;&#x2F;签名类型        “signType”: “RSA”,(只能RSA)         &#x2F;&#x2F;该sign通过加密算法生成        “paySign”: “oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq/xDg&#x3D;&#x3D;”,        “success”:function(res){},        “fail”:function(res){},        “complete”:function(res){}    })\n这个功能  其实和v2的参数大相径庭  重点依旧是获取prepay_id  和  paysign也就是重点是从后面开始 会有截然不同的体现jsapi下单接口url：https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi参数：‘appid’ &#x3D;&gt; $this-&gt;appid, &#x2F;&#x2F;小程序 ID‘mch_id’ &#x3D;&gt; $this-&gt;mch_id, &#x2F;&#x2F;商户号‘description’ &#x3D;&gt; 商品描述,‘out_trade_no’ &#x3D;&gt; ‘2018013106125348’, &#x2F;&#x2F;商户订单号‘notify_url’ &#x3D;&gt;‘’, &#x2F;&#x2F;通知地址  确保外网能正常访问‘payer’：{‘openid’ &#x3D;&gt; $this-&gt;openid}, &#x2F;&#x2F;用户 id‘amount：{‘total’ &#x3D;&gt; 100}, &#x2F;&#x2F;金额例如：{    “mchid”: “1900006XXX”,    “out_trade_no”: “1217752501201407033233368318”,    “appid”: “wxdace645e0bc2cXXX”,    “description”: “Image形象店-深圳腾大-QQ公仔”,    “notify_url”: “https://weixin.qq.com/“,    “amount”: {        “total”: 1,        “currency”: “CNY”    },    “payer”: {        “openid”: “o4GgauInH_RCEdvrrNGrntXDuXXX”    }}这就是所有要传入的参数 细心的你们会发现 参数里并没有发现sign那么v3的接口到底如何调用  我们需要的sign又是如何生成的呢？？？具体的如下：\n\n第一步：\n\n我们有了以上的参数后 就可以进行签名（第一次签名）第一次签名 并不再是单纯的依靠我们的参数进行签名  ，而是已一种http协议格式的字符串进行签名：例如HTTP请求方法\\n URL\\n 请求时间戳\\n 请求随机串\\n 请求报文主体\\n以上的  请求方法：get&#x2F;post        url  网关请求时间戳（自主生成）&#x2F;请求随机串（自主生成）&#x2F;报文主体：我们的参数对这个字符串先进行sha256编码在对编码后的字符串进行rsa加密得到的第一次签名的sign备注：这个sign并不需要加入到参数中  ，而是在我们向微信提交请求时 放在请求头中auth_info &#x3D; ‘WECHATPAY2-SHA256-RSA2048 {}’.format(sign)headers[‘Authorization’] &#x3D; auth_info如此我们便能得到prepay_id，那么就还是小程序所需要的paysign那么小程序所需要的paysign  在v3的接口里是怎么生成的呢如下：当我们拿到prepay_id以后我们需要拼接一个这样格式的字符串：‘{}\\n{}\\n{}\\n{}\\n’.format(self.mch_appid, ts, nonce, prepay_id)举例： Appid\\n时间戳\\随机字符串\\nprepay_id&#x3D;******对上面所诉的字符串在进行签名得到小程序调起支付所需要的paysign返给前端：至此v3版本支付功能结束由于V3版本设计到了RSA和sha256等算法，这两种算法都封装于openssl里面Sha256  把一个字符串进行sha256后会成为一个256bit的哈希值（跟md5一样不可逆）比如：A7FCFC6B5269BDCCE571798D618EA219A68B96CB87A0E21080C2E758D23E4CE9Rsa ①则是一种对称加密算法 之然而然  就会有加密的密钥 和 解密的密钥（rsa的密钥存放在证书里））②传统的rsa 最开始是1028位的 ，最新的暴力破解已经尝试到了986位，所以 微信使用的全是最新的rsa256（密钥长度为 2056位）（这一点跟支付宝一样，支付宝提供个人沙箱环境 只支持rsa256加密））\n","categories":["前端"],"tags":["小程序"]},{"title":"微信小程序 webview 与 h5 的通信","url":"/2022/12/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20webview%20%E4%B8%8E%20h5%20%E7%9A%84%E9%80%9A%E4%BF%A1/","content":"参考资料Uniapp 内嵌H5跳转内嵌小程序页面uniapp h5项目点击跳转小程序，h5传参到小程序微信小程序与h5通过web-view传值[填坑手册]小程序web-view组件实战与踩坑\n首先因为微信小程序无法打开本地资源管理器。所以都是通过微信的wx.chooseMessageFile进行在本地聊天记录中选取文件。（这种方法也是目前大部分小程序采取上传文件的方式优点是：速度快、兼容性好。缺点：用户需要提前把文件发送给自己聊天列表中的随便一个人）wx.chooseMessageFile代码实现\nwx.chooseMessageFile(&#123;  count: 10,  type: &#x27;file&#x27;, //\t选择了除图片和视频的文件  success (res) &#123;    // tempFilePath可以作为 img 标签的 src 属性显示图片    const tempFilePaths = res.tempFiles  &#125;&#125;)\n\n现在需要直接通过微信小程序去访问本地的资源管理器。我的解决思路的是，通过微信小程序使用webview去调用一个h5页面。在通过h5页面去调用本地资源。选取后将资源上传服务器，在返回到小程序。这里比较困难的是小程序向webview传值以及webview跳回小程序，以及返回参数到小程序。\n这里首先需要写一个h5的页面进行上传文件,这里需要引入小程序的一个sdk,uniapp使用 npm install --save-dev weixin-js-sdk。然后在main.js里进行全局引入let jweixin = require(&#39;jweixin-module&#39;) Vue.prototype.$wx = jweixin。\n&lt;template&gt;\t&lt;view class=&quot;content&quot;&gt;\t\t&lt;view class=&quot;add-btn&quot;&gt;\t\t\t&lt;text class=&quot;text&quot; @click=&quot;openFile&quot;&gt;添加附件&lt;/text&gt;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport wx from &#x27;@/static/activity_sdk.js&#x27;;\texport default &#123;\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttitle: &#x27;Hello&#x27;,\t\t\t\tid: &#x27;&#x27;,\t\t\t\ttoken: &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\t// 打开文件选择器\t\t\topenFile() &#123;\t\t\t\tlet that = this\t\t\t\tuni.chooseFile(&#123;\t\t\t\t\tcount: 1, //默认100\t\t\t\t\textension: [&#x27;.mp3&#x27;, &#x27;.m4a&#x27;],\t\t\t\t\tsuccess: (res) =&gt; &#123;\t\t\t\t\t\tconsole.log(res);\t\t\t\t\t\tif (res.tempFiles[0].size / 1024 / 1024 &gt; 20) &#123;\t\t\t\t\t\t\tthat.$refs.uToast.show(&#123;\t\t\t\t\t\t\t\ttitle: &#x27;附件大小不能超过20M&#x27;,\t\t\t\t\t\t\t\ttype: &#x27;warning&#x27;,\t\t\t\t\t\t\t&#125;)\t\t\t\t\t\t\treturn;\t\t\t\t\t\t&#125;\t\t\t\t\t\tvar params = &#123;\t\t\t\t\t\t\tpath: res.tempFilePaths[0],\t\t\t\t\t\t\tname: res.tempFiles[0].name,\t\t\t\t\t\t\torderid: 0,\t\t\t\t\t\t&#125;\t\t\t\t\t\tthat.uploadFile(params);\t\t\t\t\t&#125;\t\t\t\t&#125;);\t\t\t&#125;,\t\t\tuploadFile(params, noRefetch) &#123;\t\t\t\tuni.showLoading(&#123;\t\t\t\t\ttitle: &#x27;上传中...&#x27;,\t\t\t\t&#125;);\t\t\t\tvar that = this;\t\t\t\tvar url = &#x27;https://dub.wuhanzhuangxiu01.cn/uploadMusic&#x27;;\t\t\t\tvar name = params.name ? params.name : &#x27;&#x27;;\t\t\t\tvar key = params.key ? params.key : &#x27;&#x27;;\t\t\t\tvar ii = params.ii ? params.ii : 0;\t\t\t\tvar orderid = params.orderid ? params.orderid : 0;\t\t\t\tvar id = that.id ? that.id : 0;\t\t\t\tuni.uploadFile(&#123;\t\t\t\t\turl: url,\t\t\t\t\tfilePath: params.path,\t\t\t\t\tfileType: &#x27;audio&#x27;,\t\t\t\t\tname: &#x27;file&#x27;,\t\t\t\t\theader: &#123;\t\t\t\t\t\t&#x27;token&#x27;: that.token,\t\t\t\t\t&#125;,\t\t\t\t\tformData: &#123;\t\t\t\t\t\t&#x27;path&#x27;: params.path,\t\t\t\t\t\t&#x27;name&#x27;: name,\t\t\t\t\t\t&#x27;key&#x27;: key,\t\t\t\t\t\t&#x27;ii&#x27;: ii,\t\t\t\t\t\t&#x27;uid&#x27;: id,\t\t\t\t\t\t&#x27;orderid&#x27;: orderid\t\t\t\t\t&#125;,\t\t\t\t\tsuccess: function(res) &#123;\t\t\t\t\t\tvar data = JSON.parse(res.data);\t\t\t\t\t\tuni.hideLoading();\t\t\t\t\t\tthat.$wx.miniProgram.postMessage(&#123;\t\t\t\t\t\t\tdata: &#123;\t\t\t\t\t\t\t\tname: data,\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;);\t\t\t\t\t\tthat.$wx.miniProgram.navigateBack(&#123;\t\t\t\t\t\t\tdelta: 1\t\t\t\t\t\t&#125;)\t\t\t\t\t&#125;,\t\t\t\t\tfail: function(res) &#123;\t\t\t\t\t\tconsole.log(&#x27;fail:&#x27;, res);\t\t\t\t\t\tuni.hideLoading();\t\t\t\t\t\tuni.showLoading(&#123;\t\t\t\t\t\t\ttitle: &#x27;上传失败&#x27;,\t\t\t\t\t\t\ticon: &#x27;error&#x27;\t\t\t\t\t\t&#125;);\t\t\t\t\t\tthat.$wx.miniProgram.navigateBack(&#123;\t\t\t\t\t\t\tdelta: 1\t\t\t\t\t\t&#125;)\t\t\t\t\t&#125;,\t\t\t\t&#125;)\t\t\t&#125;,\t\t&#125;,\t\tonLoad(e) &#123;\t\t\tconsole.log(&#x27;h5页面&#x27;, e);\t\t\tthis.id = e.id\t\t\tthis.token = e.token\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;\t.add-btn &#123;\t\twidth: 100%;\t\theight: 100vh;\t\tdisplay: flex;\t\tjustify-content: center;\t\talign-items: center;\t&#125;\t.add-btn text &#123;\t\tdisplay: block;\t\ttext-align: center;\t\tline-height: 100rpx;\t\twidth: 80%;\t\theight: 100rpx;\t\tbackground-color: cadetblue;\t\tborder-radius: 20rpx;\t\t/* margin: 0 auto; */\t&#125;&lt;/style&gt;\n\n这里从webview的网页跳回小程序有个问题。就是只能用navigateBack进行返回。原因不明。文档上说的是navigateTo、navigateBack、switchTab、reLaunch、redirectTo都能使用，但是在我的环境下只能使用navigateBack进行返回。传值我是通过webview的bindmessage属性进行传值。首先在webview定义好属性写好回调。在h5页面，使用wx.miniProgram.postMessage来进行传值。传的值会在 bindmessage定义好的函数里形参里。因为之前我是使用 navigateBack进行返回的。所以返回的值一直在webview页面。我需要传值给我的返回的这个界面。我在app.js里面定义一个属性进行页面之间的通信。在webview页面接受传回来的值，存放在app.js上面的属性。在跳转的页面进行拿取传过来的值。就能完成从webview传值给微信小程序。\n微信小程序webview示例代码：\n&lt;!-- wxml部分 --&gt;&lt;web-view src=&quot;&#123;&#123;&#x27;https://dub.wuhanzhuangxiu01.cn/uploading/upload/&#x27;+&#x27;#/?id=&#x27;+id+&#x27;&amp;token=&#x27;+token&#125;&#125;&quot; bindload=&quot;load&quot; bindmessage=&quot;msgHandler&quot;&gt;&lt;/web-view&gt;&lt;!-- js部分 --&gt;let app = getApp()Page(&#123;  /**   * 页面的初始数据   */  data: &#123;    id:&quot;&quot;,    token:&quot;&quot;  &#125;,  //可以捕获到url的监听事件函数  load: function (e) &#123;    // 获取url    const src = e.detail.src;    console.log(src);  &#125;,  &lt;!-- 通信函数 --&gt;  msgHandler: function (e) &#123; //(h5像小程序传递参数）    console.log(&#x27;传回的值&#x27;,e.detail.data[0]) //获取到来自也页面的数据    app.muName = e.detail.data[0]  &#125;,  /**   * 生命周期函数--监听页面加载   */  onLoad(options) &#123;    this.setData(&#123;      id:options.id,      token:options.token    &#125;)  &#125;,&#125;)\n\n这部分代码中的wxml部分，src部分不要问我怎么写这么复杂，我也不想写这么复杂。我试了无数次，只有这么写，才能带参数，访问这个h5页面。之前我是先将url合并之后一块给src,但是这个h5会在链接自动生成#在路径里。然后微信这边会自动将#号过滤掉。这个#号是因为路由器的两种工作模式之一的hash模式造成的。\n\nhash ——即地址栏URL中的#符号。 hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。\n\n\nhistory ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法。需要特定浏览器支持 history模式，会出现404 的情况，需要后台配置。\n\n\nhash模式下，仅hash符号之前的内容会被包含在请求中，如 https://www.shopwind.net, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误；\n\n\nhistory模式下，前端的url必须和实际向后端发起请求的url 一致，如https://www.shopwind.net/a/ 。如果后端缺少对&#x2F;a 的路由处理，将返回404错误\n\n详解可见 Uniapp发布为H5版本时如何隐藏访问路径的#符号\n因为我这边后端是别人搭好的，如果要改，可能有连锁反应，所以我最后，在不断百度，不断百度，不断百度。最后在犄角旮旯找到一篇文章，在文章的评论里找到一条评论，让我在webview里直接将#/以字符串的形式加进去，能直接访问。于是就有了这部分内容。\n","categories":["前端"],"tags":["js"]},{"title":"拖拉拽","url":"/2022/12/02/%E6%8B%96%E6%8B%89%E6%8B%BD/","content":"推拉拽\n如下图效果：\n备注：上图右边的小程序的样式 是随左边的后台模板设计而动态的改变的\n要想实现整个流程 特从2大环节来分享\n第一环节后台模板设计：使用技术要点：\n\n非vue项目使用  sortable.js\nVue项目 使用vuedraggable组件\n\n(实现拖拽)\n非vue项目\n\n\nVue项目Npm install vuedraggableimport draggable from ‘vuedraggable’\n不管是vue项目还是非vue项目   底层实现拖拽的逻辑大致一样,如下：先用一个大的元素  把需要拖拽的元素包裹起来，再去安排每一个需要拖动的元素例如：（一）非vue项目（最外层指定一个属性id  此处为contentltm）然后在js代码指定这个元素里面具体那些子元素可以拖动  一般为div（二）vue项目当安装好vuedragable组件后 最外层的大元素不再是原生的div  而转为draggable组件\n该组件参数参考开发文档https://sortablejs.github.io/Vue.Draggable/#/clone以下已几个重要的参数 稍微讲解一下list 此为一个数组   里面每一个值就是一个元素change事件 当我们试图改变元素的位置时触发add事件  当添加元素时触发end事件  当移动整个元素结束时触发\n如上：则可以实现元素的拖动效果测试demo连接：非vue项目：https://newsaas.guangzhouzhuangxiu01.cn/CIPKeogzAx.php/index/shopdesign/ids/5?ref=addtabsvue项目：https://saas.guangzhouzhuangxiu01.cn/vuedrag/dist\n以上我们完成了在页面上实现拖拽的功能 ，自此我们是可以让用户自由的搭建他们想要的排版的样式，那么就引出了第二步的问题 \n假想一下：我们实现定义好了20个div  对应着20个不同的组件  每个组件里面有着属于组件自己的功能   此时 当用户随机在这个20个div里找到自己想要的  并对这些进行了拖拉拽排序 ，那么用户的小程序又要如何按照用户设计的那样显示出来。\n第一步 我们先要保存好用户已经设计好了界面 那么要用什么样的格式来保存数据\n\n数组 单纯的保留组件的名称  所有的组件功能是写死的  只给用户排版的能力（公司买的花店小程序后台）\nJson数组 把组件名称 和 组件所需要的数据  全部存放其中，这样用户的体验更加灵活但是代码就会更加的冗余\n\n\n我们把用户排版好的数据按照json的形式存放到数据库，当页面渲染时 通过wxappid调用获取到这个json数组 就可以了\n到此 整个流程看似结束了 ，但是坑来了\n我们需要界面动态的渲染这些后端返回给我们的组件首先 我们百度下vue 是如何动态渲染组件的\n可以看到 vue是通过compontent 来根据组件名 动态渲染组件，但不幸的是  小程序不支持compontent  当你使用时会飘红\n不能用compontent来实现动态渲染组件  只有用最原生的办法  通过for循环来加载我们的组件方法如下图所示：先定义并导入我们写好的组件页面加载时通过接口获取到用户自己定义的组件列表\n通过for循环来加载我们的组件  注意 v-if 根据组件名来判断显不显示它\n到此为止  我们已经实现了一个小型的凡科网\n最后送给摸鱼的大家一句话：\n让代码帮我们办事别让我们写代码办事\n","categories":["前端"],"tags":["js"]},{"title":"插屏广告封装","url":"/2022/07/20/%E6%8F%92%E5%B1%8F%E5%B9%BF%E5%91%8A%E5%B0%81%E8%A3%85/","content":"// 插屏广告var interstitialAd = null;let interstitial = &#123;\t//id就是传入的广告位id\tload(id,meth) &#123;\t\tif (uni.createInterstitialAd) &#123;\t\t\tinterstitialAd = uni.createInterstitialAd(&#123;\t\t\t\tadUnitId: id\t\t\t&#125;)\t\t\tinterstitialAd.onLoad(() =&gt; &#123;\t\t\t\tconsole.log(&#x27;插屏 广告加载成功&#x27;)\t\t\t\t// setTimeout(()=&gt;&#123;\t\t\t\t// \tinterstitialAd.show()\t\t\t\t// &#125;,6000)\t\t\t&#125;)\t\t\tinterstitialAd.onError((err) =&gt; &#123;\t\t\t\tconsole.log(&#x27;插屏 广告加载失败&#x27;, err)\t\t\t\t\t// interstitialAd.show()\t\t\t&#125;)\t\t\tinterstitialAd.onClose((res) =&gt; &#123;\t\t\t\tconsole.log(&#x27;插屏 广告关闭&#x27;, res)\t\t\t\tsetTimeout(()=&gt;&#123;\t\t\t\t\tinterstitialAd.show()\t\t\t\t&#125;,6000)\t\t\t&#125;)\t\t&#125;\t&#125;,\tshow() &#123;\t\tif (interstitialAd) &#123;\t\t\tinterstitialAd.show().catch((err) =&gt; &#123;\t\t\t\tconsole.error(err)\t\t\t&#125;)\t\t&#125;\t&#125;&#125;module.exports = &#123;\tinterstitial&#125;;\n","categories":["前端"],"tags":["小程序"]},{"title":"操作vue中data数据","url":"/2021/04/15/%E6%93%8D%E4%BD%9Cvue%E4%B8%ADdata%E6%95%B0%E6%8D%AE/","content":"1.操作dataObject.assign(this.$data,对象)\n","categories":["前端"],"tags":["vue"]},{"title":"数据结构与算法","url":"/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"数据结构概述数据结构是指相互之间存在一种或多种特定关系数据元素的集合\n逻辑结构数据对象中数据元素之间的相互关系① 集合结构：数据元素之间的唯一关系就是属于同一个集合② 线性结构：数据元素之间存在一对一的关系（除首尾元素均存在前驱和后继）③ 树形结构：数据元素之间存在一对多的关系④ 图形结构：数据元素之间存在多对多的关系\n\n（每一个数据元素看做一个节点，元素之间的逻辑关系用连线表示，如果关系有方向则连线带箭头）\n\n\n物理结构(存储结构)数据的逻辑结构关系在计算机中的存储形式① 顺序存储结构：把元素分别放在地址连续的存储单元中的存储方式\n\n也就是说：元素一个一个有序的排好队，各自占据一定的空间，例如定义一个含有6个浮点型数据的数组：然后内存中的一块大小为6个浮点型数据大小空间就会被计算机所开辟，然后数据存入时，依次顺序摆入\n\n② 链式存储结构：把元素存储在任意的存储单元中的存储方式\n\n因为数据元素位置不确定，所以需要通过指针指向到元素的存储地址，从而确定不同数据元素之间的位置\n\n③ 散列 (哈希) 存储方式：是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术\n\n它的原理就是，将一个节点的关键字key作为自变量，通过一个确定的函数运算f(key)，其函数值作为节点的存储地址，将节点存入到指定的位置上，查找的时候，被搜索的关键字会再次通过f(key)函数计算地址，然后读取对应数据\n\n④ 索引存储方式：存储时，除了存储节点，还附加建立了索引表来表示节点的地址\n算法概述算法的特征\n输入：算法具有零个或者多个输入（零个的情况例如打印输出字符串，或者算法自身已经给定了初始条件）\n输出：算法具有一个或者多个输出，用来反映算法对输入数据加工后的结果\n有穷性：算法必须在执行有限个步骤后终止，“有限” 的定义不是绝对的，而是实际应用中合理的可接受的\n确定性： 算法的每一步骤都具有确定的含义，不会出现二义性\n也就是说，唯一的输入只有唯一的输出\n\n\n可行性：算法的每一步都是可行的，通过有限步骤可以实现\n\n算法的设计要求\n正确性：合理的数据输入下，最终可以输出能解决问题需求的正确答案\n对正确的理解：\n无语法错误\n输入合法和非法的数据均可以得到正确答案\n输入刁难的数据依旧可以输出满足需要的答案\n\n\n\n\n可读性：算法便于阅读和理解\n算法应该层次分明，易读易懂，方便二次调试和修改\n复杂一些的算法，变量的命名尽量恰当一些，用阿里的开发手册中的一句话就是说：“正确的英文拼写和语法可以让阅读者易与理解避免歧义”，“为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意”\n\n\n健壮性：当数据不合理的时候，算法也能对各种情况作出处理，而不是报出异常，或者输出错误的答案\n高效性：尽量满足时间效率高，存储率低的需求\n\n算法的时间复杂度时间复杂度通常用来衡量算法的运行时间算法的时间复杂度是一个函数 T(n)，它定性描述该算法的运行时间，通常用大O表示法。记作：T(n) &#x3D; O(f(n)) 例如3n² + 2n + 1 的时间复杂度为 O(n²)常见的时间复杂度量级有：\n\n常数阶O(1)\n对数阶O(logN)\n线性阶O(n)\n线性对数阶O(nlogN)\n平方阶O(n²)\n立方阶O(n³)\nK次方阶O(n^k)\n指数阶(2^n)\n\n上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。\n常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\nint i = 1;int j = 2;++i;j++;int m = i + j;\n线性阶O(n)for(i=1; i&lt;=n; ++i)&#123;   j = i;   j++;&#125;\n这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。\n对数阶O(logN)int i = 1;while(i&lt;n)&#123;    i = i * 2;&#125;\n在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。那么假设循环x次之后，i 就大于 2 了，此时这个循环就退出了。也就是说有 x 个 2 相乘后大于 n，则会退出循环。表示出来就是 2^x&#x3D;n，得到 x &#x3D; log2^n。因此这个代码的时间复杂度为：O(logn)\n线性对数阶O(nlogN)for(m=1; m&lt;n; m++)&#123;    i = 1;    while(i&lt;n)    &#123;        i = i * 2;    &#125;&#125;\n将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。\n平方阶O(n²)for(x=1; i&lt;=n; x++)&#123;   for(i=1; i&lt;=n; i++)    &#123;       j = i;       j++;    &#125;&#125;\n这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的n改成m，即：\nfor(x=1; i&lt;=m; x++)&#123;   for(i=1; i&lt;=n; i++)    &#123;       j = i;       j++;    &#125;&#125;\n那它的时间复杂度就变成了 O(m*n)\n立方阶O(n³)和K次方阶O(n^k)参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。\n算法的空间复杂度空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。空间复杂度比较常用的有：O(1)、O(n)、O(n²)\n时间复杂度大小排序O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)\n空间复杂度 O(1)如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)\nint i = 1;int j = 2;++i;j++;int m = i + j;\n代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) &#x3D; O(1)\n空间复杂度 O(n)int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123;   j = i;   j++;&#125;\n这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) &#x3D; O(n)\n\n\n","categories":["数据结构"],"tags":["算法"]},{"title":"配音圈配音","url":"/2022/08/02/%E9%85%8D%E9%9F%B3%E5%9C%88%E9%85%8D%E9%9F%B3%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9C%B0%E6%96%B9/","content":"配音圈配音的模块化ES6的Class 类    在传统的js语法当中，如果我们想创建一个实例对象的时候一般会先定义一个构造函数，然后通过new运算符来创建一个实例对象，例如: \n\nfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;Person.prototype.showName = function()&#123;    console.log(this.name)&#125;Person.prototype.showAge = function()&#123;    console.log(this.age)&#125;var person = new Person(&#x27;xz&#x27;,21)person.showName()//&#x27;xz&#x27;person.showAge()//21\n\n我们定义一个Person的构造函数，然后通过new Person()来创建一个实例对象。一般我们向构造函数的原型上添加方法，表示实例要继承的方法，这个方法是公共的，不是某个实例自己特有的方法。这样我们就可以完成一个具体的实例了。而在ES6中，为我们提供了一个叫Class的一个方法,让我们能够更容易理解和创建一个实例对象。例如： \nclass Person &#123;    constructor(name,age)&#123;        this.name = name        this.age = age    &#125;    showName()&#123;//为我们的实例添加继承的方法        console.log(this.name)    &#125;    showAge()&#123;//为我们的实例添加继承的方法        console.log(this.age)    &#125;&#125;var person = new Person(&#x27;xz&#x27;,21)\tperson.showName()//&#x27;xz&#x27;\tperson.showAge()//21\n\n注意： \n     -  如果使用es6的class类语法要注意一点就是 `constructor`方法是类默认方法，通过`new`命令生成对象实例时自动调用该方法。一个类必须有一个`constructor`方法，如果没有显示定义，那么一个空的`constructor`方法会被默认添加。 \n     -  类的声明不存在变量提升 \n\nnew Person()//报错，因为类的声明不存在变量提升class Person&#123;    constructor()&#123;        this.name = &#x27;xz&#x27;        this.age = 21    &#125;&#125;\njs类的继承根据ES6的语法，super关键字，extends来进行类的继承操作我们可以通过extends关键字来实现子类对父类的继承。子类必须在constructor方法中调用super方法，否则新建的实例会报错。原因在于子类没有自己的this对象，而是继承父类的this对象，然后进行加工，如果不调用super关键字，那么子类就拿不到this对象，而super在其中表示的其实是父类的构造函数 \nclass sup&#123;    constructor()&#123;&#125;    show()&#123;//向父类的原型上挂载show()方法        console.log(&#x27;sup&#x27;)    &#125;&#125;class sub extends sup&#123;    constructor()&#123;        super()    &#125;    showinfo()&#123;        console.log(super.show())    &#125;&#125;var obj = new sub()obj.showinfo()//sup\n配音圈配音的utils里有6个文件,模块化的大致思路是一样的。举例： \n\nconfig.js \nclass Config&#123;    constructor()&#123;    &#125;&#125;Config.restUrl = &#x27;https://dub.wuhanzhuangxiu01.cn&#x27;;Config.onPay = true;  //是否启用支付........export &#123;Config&#125;;\n\n\nbase.js \n/** *  自定义基类 */import &#123;  Config&#125; from &#x27;./config.js&#x27;;var app = getApp();class Base &#123;  constructor() &#123;    this.baseRequestUrl = Config.restUrl;  &#125;  /**   * 封装request请求   */  request(params, noRefetch) &#123;    var url = this.baseRequestUrl + params.url;    var that = this;    /* 判断请求方式 默认为&#x27;POST&#x27; */    if (!params.type) &#123;      params.type = &#x27;POST&#x27;;    &#125;    wx.request(&#123;      url: url,      data: params.data,      header: &#123;        &#x27;content-type&#x27;: &#x27;application/json&#x27;,        &#x27;token&#x27;: wx.getStorageSync(&#x27;token&#x27;),      &#125;,      method: params.type,      dataType: &#x27;json&#x27;,      responseType: &#x27;text&#x27;,      success: function (res) &#123;        // res.data.param.disable == 1? wx.setStorageSync(&#x27;disable&#x27;, 1): wx.setStorageSync(&#x27;disable&#x27;, 0);        var code = res.statusCode.toString();        var startChar = code.charAt(0);        if (startChar == &#x27;2&#x27;) &#123;          params.sCallback &amp;&amp; params.sCallback(res.data);        &#125; else &#123;          that._processError(res);          params.eCallback &amp;&amp; params.eCallback(res.data);        &#125;      &#125;,      fail: function (res) &#123;        that._processError(res);      &#125;,    &#125;)  &#125;  /**   * 消息提示   */  showToast(title, icon) &#123;    if (!icon) &#123;      icon = &#x27;none&#x27;;    &#125;    wx.showToast(&#123;      title: title,      icon: icon,      duration: 2000,    &#125;)  &#125;  ........&#125;export &#123;  Base&#125;;\n\n\npublic.js \n/** * Home * 自定义类 */import &#123;    Base&#125; from &#x27;../../utils/base.js&#x27;;class Public extends Base &#123;    constructor() &#123;        /* 必须: 调用基类的构造函数 */        super();    &#125;    /**获取金牌推荐 */    gold_recommend(data, callback) &#123;        var params = &#123;            url: &#x27;/gold_list&#x27;,            data: data,            sCallback: function (res) &#123;                callback &amp;&amp; callback(res);            &#125;,        &#125;        this.request(params);    &#125;   ........&#125;/* 输出类HOME */export &#123;    Public&#125;;\n\n\n使用 \nimport &#123;  Public&#125; from &#x27;../tpls/public.js&#x27;;var pub = new Public();Page(&#123;    onLoad()&#123;        pub.gold_recommend(&#123;            &#x27;page&#x27;: 1,            &#x27;limit&#x27;: 5        &#125;, (res) =&gt; &#123;            if (res.code == 200) &#123;                that.setData(&#123;                    GlodList: res.data                &#125;)            &#125;        &#125;);    &#125;&#125;)\n\n登录模块小程序的生命周期 \n\nonReady 生命周期函数–监听页面初次渲染完成onShow 生命周期函数–监听页面显示onHide 生命周期函数–监听页面隐藏onUnload 生命周期函数–监听页面卸载onPullDownRefresh 页面相关事件处理函数–监听用户下拉动作onReachBottom 页面上拉触底事件的处理函数onShareAppMessage 用户点击右上角转发onPageScroll 页面滚动触发事件的处理函数onTabItemTap 当前是 tab 页时，点击 tab 时触发\n\n配音圈配音因为是用原生微信小程序进行编写的，没有watch，没有vuex,所以看似很简单的方式就很难实现。就比如进入到小程序里面先进行登录获取头像以及openid,在通过拿到的openid进行身份判断。这里的身份判断要在首页里展示，所以写在首页的onload里，而登录这个东西最早用，并且很多地方用。所以写在小程序的onlaunch函数里。但是因为onlaunch里执行的登录获取openid是个请求，有异步效果。所以在小程序执行完页面的生命周期函数的时候，可能还没有拿到openid。而配音圈配音通过一个回调函数解决了这个问题。总结来说就是微信小程序app.js的onLaunch中的异步请求执行完之后再执行Page的onLoadapp.js\nApp(&#123;  globalData: &#123;    employ: &#x27;&#x27;,    onLaunchData: null,  &#125;,  onLaunch: function () &#123;    console.log(&quot;onlaunch&quot;);    let that = this;    wx.request(&#123;      url: &#x27;http://101.35.96.100:8001/miniprograms/tideForecast/getAreaList&#x27;,      method: &#x27;POST&#x27;,      data: &#123;&#125;,      success: function (res) &#123;        console.log(res);        //设置请求的值        that.globalData.onLaunchData = res.data.data        //设置请求状态        that.globalData.employ = true;       //由于这里是网络请求，可能会在 Page.onLoad 之后才返回  在onLoad中定义下app.employCallback 后才执行下述that.employCallback(true)，此时用户数据肯定得到了，回调内再则可获取到用户数据       //所以此处加入 callback 以防止这种情况        if (that.employCallback) &#123;          that.employCallback(true);        &#125;      &#125;,    &#125;);  &#125;,&#125;)\nindex.js\nconst app = getApp()Page(&#123;  data: &#123;    onLaunchData:null,  &#125;,  onLoad: function (options) &#123;    let that = this;    console.log(&quot;onload&quot;);    if (app.globalData.employ &amp;&amp; app.globalData.employ != &#x27;&#x27;) &#123;      console.log(&quot;first&quot;)      let onLaunchData = app.globalData.onLaunchData;      that.setData(&#123;        onLaunchData: onLaunchData ? onLaunchData : null      &#125;);    &#125; else &#123;      // 由于 onLaunch里执行的 是网络请求，可能会在 Page.onLoad 之后才返回      // 所以此处加入 callback 以防止这种情况      app.employCallback = employ =&gt; &#123;        console.log(&quot;进入到app.employCallback&quot;);        console.log(that);        if (employ != &#x27;&#x27;) &#123;          console.log(employ);          that.setData(&#123;            onLaunchData: app.globalData.onLaunchData          &#125;);                 &#125;      &#125;    &#125;  &#125;,&#125;)\n这里执行的流程是当微信小程序运行时，首先进入到了onLaunch进行执行，因为onLaunch里面有request是异步请求，所以压力来到了index.js的onload里面，在onload里去判断app.js里的数据状态是什么样的，是true就拿request里的数据，如果没有就对app,js的app对象进行添加一个回调函数属性，在这个回调函数属性里需要传入一个true就能操作index.js的page对象里的data,给onlaunch里请求的值赋值给index.js的page对象里的data。这个时候因为之前在onLaunch写的调用自己的在index.js里写的回调，并传入true,对index.js中data中的数据进行赋值。 \nh5上传文件模块参考资料Uniapp 内嵌H5跳转内嵌小程序页面uniapp h5项目点击跳转小程序，h5传参到小程序微信小程序与h5通过web-view传值[填坑手册]小程序web-view组件实战与踩坑首先因为微信小程序无法打开本地资源管理器。所以都是通过微信的wx.chooseMessageFile进行在本地聊天记录中选取文件。（这种方法也是目前大部分小程序采取上传文件的方式优点是：速度快、兼容性好。缺点：用户需要提前把文件发送给自己聊天列表中的随便一个人）wx.chooseMessageFile代码实现 \nwx.chooseMessageFile(&#123;  count: 10,  type: &#x27;file&#x27;, //\t选择了除图片和视频的文件  success (res) &#123;    // tempFilePath可以作为 img 标签的 src 属性显示图片    const tempFilePaths = res.tempFiles  &#125;&#125;)\n\n现在需要直接通过微信小程序去访问本地的资源管理器。我的解决思路的是，通过微信小程序使用webview去调用一个h5页面。在通过h5页面去调用本地资源。选取后将资源上传服务器，在返回到小程序。这里比较困难的是小程序向webview传值以及webview跳回小程序，以及返回参数到小程序。这里首先需要写一个h5的页面进行上传文件,这里需要引入小程序的一个sdk,uniapp使用 npm install --save-dev weixin-js-sdk。然后在main.js里进行全局引入let jweixin = require(&#39;jweixin-module&#39;) Vue.prototype.$wx = jweixin。 \n&lt;template&gt;  &lt;view class=&quot;content&quot;&gt;    &lt;view class=&quot;add-btn&quot;&gt;      &lt;text class=&quot;text&quot; @click=&quot;openFile&quot;&gt;添加附件&lt;/text&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;  import wx from &#x27;@/static/activity_sdk.js&#x27;;  export default &#123;    data() &#123;      return &#123;        title: &#x27;Hello&#x27;,        id: &#x27;&#x27;,        token: &#x27;&#x27;      &#125;    &#125;,    methods: &#123;      // 打开文件选择器      openFile() &#123;        let that = this        uni.chooseFile(&#123;          count: 1, //默认100          extension: [&#x27;.mp3&#x27;, &#x27;.m4a&#x27;],          success: (res) =&gt; &#123;            console.log(res);            if (res.tempFiles[0].size / 1024 / 1024 &gt; 20) &#123;              that.$refs.uToast.show(&#123;                title: &#x27;附件大小不能超过20M&#x27;,                type: &#x27;warning&#x27;,              &#125;)              return;            &#125;            var params = &#123;              path: res.tempFilePaths[0],              name: res.tempFiles[0].name,              orderid: 0,            &#125;            that.uploadFile(params);          &#125;        &#125;);      &#125;,      uploadFile(params, noRefetch) &#123;        uni.showLoading(&#123;          title: &#x27;上传中...&#x27;,        &#125;);        var that = this;        var url = &#x27;https://dub.wuhanzhuangxiu01.cn/uploadMusic&#x27;;        var name = params.name ? params.name : &#x27;&#x27;;        var key = params.key ? params.key : &#x27;&#x27;;        var ii = params.ii ? params.ii : 0;        var orderid = params.orderid ? params.orderid : 0;        var id = that.id ? that.id : 0;        uni.uploadFile(&#123;          url: url,          filePath: params.path,          fileType: &#x27;audio&#x27;,          name: &#x27;file&#x27;,          header: &#123;            &#x27;token&#x27;: that.token,          &#125;,          formData: &#123;            &#x27;path&#x27;: params.path,            &#x27;name&#x27;: name,            &#x27;key&#x27;: key,            &#x27;ii&#x27;: ii,            &#x27;uid&#x27;: id,            &#x27;orderid&#x27;: orderid          &#125;,          success: function(res) &#123;            var data = JSON.parse(res.data);            uni.hideLoading();            that.$wx.miniProgram.postMessage(&#123;              data: &#123;                name: data,              &#125;            &#125;);            that.$wx.miniProgram.navigateBack(&#123;              delta: 1            &#125;)          &#125;,          fail: function(res) &#123;            console.log(&#x27;fail:&#x27;, res);            uni.hideLoading();            uni.showLoading(&#123;              title: &#x27;上传失败&#x27;,              icon: &#x27;error&#x27;            &#125;);            that.$wx.miniProgram.navigateBack(&#123;              delta: 1            &#125;)          &#125;,        &#125;)      &#125;,    &#125;,    onLoad(e) &#123;      console.log(&#x27;h5页面&#x27;, e);      this.id = e.id      this.token = e.token    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  .add-btn &#123;    width: 100%;    height: 100vh;    display: flex;    justify-content: center;    align-items: center;  &#125;  .add-btn text &#123;    display: block;    text-align: center;    line-height: 100rpx;    width: 80%;    height: 100rpx;    background-color: cadetblue;    border-radius: 20rpx;    /* margin: 0 auto; */  &#125;&lt;/style&gt;\n\n这里从webview的网页跳回小程序有个问题。就是只能用navigateBack进行返回。文档上说的是navigateTo、navigateBack、switchTab、reLaunch、redirectTo都能使用，但是在我的环境下只能使用navigateBack进行返回。传值我是通过webview的bindmessage属性进行传值。首先在webview定义好属性写好回调。在h5页面，使用wx.miniProgram.postMessage来进行传值。传的值会在 bindmessage定义好的函数里形参里。因为之前我是使用 navigateBack进行返回的。所以返回的值一直在webview页面。我需要传值给我的返回的这个界面。我在app.js里面定义一个属性进行页面之间的通信。在webview页面接受传回来的值，存放在app.js上面的属性。在跳转的页面进行拿取传过来的值。就能完成从webview传值给微信小程序。微信小程序webview示例代码： \n&lt;template&gt;  &lt;view class=&quot;content&quot;&gt;    &lt;view class=&quot;add-btn&quot;&gt;      &lt;text class=&quot;text&quot; @click=&quot;openFile&quot;&gt;添加附件&lt;/text&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;  import wx from &#x27;@/static/activity_sdk.js&#x27;;  export default &#123;    data() &#123;      return &#123;        title: &#x27;Hello&#x27;,        id: &#x27;&#x27;,        token: &#x27;&#x27;      &#125;    &#125;,    methods: &#123;      // 打开文件选择器      openFile() &#123;        let that = this        uni.chooseFile(&#123;          count: 1, //默认100          extension: [&#x27;.mp3&#x27;, &#x27;.m4a&#x27;],          success: (res) =&gt; &#123;            console.log(res);            if (res.tempFiles[0].size / 1024 / 1024 &gt; 20) &#123;              that.$refs.uToast.show(&#123;                title: &#x27;附件大小不能超过20M&#x27;,                type: &#x27;warning&#x27;,              &#125;)              return;            &#125;            var params = &#123;              path: res.tempFilePaths[0],              name: res.tempFiles[0].name,              orderid: 0,            &#125;            that.uploadFile(params);          &#125;        &#125;);      &#125;,      uploadFile(params, noRefetch) &#123;        uni.showLoading(&#123;          title: &#x27;上传中...&#x27;,        &#125;);        var that = this;        var url = &#x27;https://dub.wuhanzhuangxiu01.cn/uploadMusic&#x27;;        var name = params.name ? params.name : &#x27;&#x27;;        var key = params.key ? params.key : &#x27;&#x27;;        var ii = params.ii ? params.ii : 0;        var orderid = params.orderid ? params.orderid : 0;        var id = that.id ? that.id : 0;        uni.uploadFile(&#123;          url: url,          filePath: params.path,          fileType: &#x27;audio&#x27;,          name: &#x27;file&#x27;,          header: &#123;            &#x27;token&#x27;: that.token,          &#125;,          formData: &#123;            &#x27;path&#x27;: params.path,            &#x27;name&#x27;: name,            &#x27;key&#x27;: key,            &#x27;ii&#x27;: ii,            &#x27;uid&#x27;: id,            &#x27;orderid&#x27;: orderid          &#125;,          success: function(res) &#123;            var data = JSON.parse(res.data);            uni.hideLoading();            that.$wx.miniProgram.postMessage(&#123;              data: &#123;                name: data,              &#125;            &#125;);            that.$wx.miniProgram.navigateBack(&#123;              delta: 1            &#125;)          &#125;,          fail: function(res) &#123;            console.log(&#x27;fail:&#x27;, res);            uni.hideLoading();            uni.showLoading(&#123;              title: &#x27;上传失败&#x27;,              icon: &#x27;error&#x27;            &#125;);            that.$wx.miniProgram.navigateBack(&#123;              delta: 1            &#125;)          &#125;,        &#125;)      &#125;,    &#125;,    onLoad(e) &#123;      console.log(&#x27;h5页面&#x27;, e);      this.id = e.id      this.token = e.token    &#125;  &#125;&lt;/script&gt;&lt;style&gt;  .add-btn &#123;    width: 100%;    height: 100vh;    display: flex;    justify-content: center;    align-items: center;  &#125;  .add-btn text &#123;    display: block;    text-align: center;    line-height: 100rpx;    width: 80%;    height: 100rpx;    background-color: cadetblue;    border-radius: 20rpx;    /* margin: 0 auto; */  &#125;&lt;/style&gt;\n\n这部分代码中的wxml部分，src部分写的很复杂。只有这么写，才能带参数，访问这个h5页面。之前我是先将url合并之后一块给src,但是这个h5会在链接自动生成#在路径里。然后微信这边会自动将#号过滤掉。这个#号是因为路由器的两种工作模式之一的hash模式造成的。    \n详解可见 Uniapp发布为H5版本时如何隐藏访问路径的#符号 \n原型与原型链\n所有函数都有一个特别的属性：**prototype**** : 显式原型属性** \n\n每个函数都有一个prototype属性, 它默认指向一个Object空对象 \n原型对象中有一个属性constructor, 它指向函数对象 \n作用: 函数的所有实例对象自动拥有原型中的属性(方法) //fun的prototype默认指向一个Object空对象console.log(Fun.prototype); // 原型对象中有一个属性constructor, 它指向函数对象console.log(Fun.prototype.constructor == Fun)Fun.prototype.test = function()&#123;console.log(&#x27;我是Fun原型上的一个方法&#x27;);&#125;let fun = new Fun()// 给原型对象添加的属性 ==&gt; 实例对象可以访问fun.test()\n\n\n所有实例对象都有一个特别的属性:**__proto__**** : 隐式原型属性** \n\n对象的隐式原型的值为其对应构造函数的显式原型的值 function Fun()&#123;&#125;let fun = new Fun()console.log(Fun.prototype === fun.__proto__)// 返回结果是true\n\n\n\n在function Fun()&#123;&#125;就相当于在内部 this.prototype = &#123;&#125;在let fun = new Fun()就相当于在内部 this.__proto__ = Fn.prototype \n\n显示原型与隐式原型在堆和栈上的结构图 function Fn()&#123;&#125;;var fn = new Fn();console.log(fn.__proto__===Fn.prototype);\n\n \n\n原型链所有的实例对象都有__proto__属性, 它指向的就是原型对象。这样通过__proto__属性就形成了一个链的结构—-&gt;原型链 \n当查找对象内部的属性&#x2F;方法时, js引擎自动沿着这个原型链查找 \n当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作 \n别名: 隐式原型链 \n作用: 查找对象的属性(方法)\n\n\n\n代码 \nfunction Fn()&#123;this.test1 = function()&#123;console.log(&quot;test1()&quot;);&#125;&#125;Fn.prototype.test2 = function()&#123;console.log(&quot;test2()&quot;)&#125;let fn = new Fn()fn.test1()fn.test2()console.log(fn.toString());fn.test3()\n图解\n\n注意： \n函数的显示原型指向的对象默认是空Object实例对象(但Object不满足) \nconsole.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true\n\n\n所有函数都是Function的实例(包含Function)\n\n\n\n\nconsole.log(Function.__proto__===Function.prototype)// true\n\nObject的原型对象是原型链尽头 console.log(Object.prototype.__proto__) // null\n\n","categories":["前端"],"tags":["小程序"]},{"url":"/2023/03/27/%E7%A5%9E%E7%B3%BB/","content":"\n\n\n荒域神系\n\n\n\n\n\n\n阵营\n名称\n地区\n徽章样式\n\n\n中混\n凛冬之神希尔顿\n极北城\n蓝底银色的三片交错的雪花\n\n\n守善\n大地之神米切尔\n极东城\n白底黄色的山脉\n\n\n守善\n森林之神朗克\n极西城\n灰底黄绿的一颗松树\n\n\n混中\n海洋之神克恩达\n极南城\n浅灰蓝色的浪涛\n\n\n中善\n霜风之神\n布莱特格罗夫区\n银色的三条波浪\n\n\n\n\n艾德堡\n\n\n\n混中\n幸运之神\n布莱顿\n一颗金色骰子\n\n\n绝对\n\n\n\n\n\n中立\n奥秘之神\n学者领\n交叉的奥秘符文\n\n\n绝对\n\n\n\n\n\n中立\n秩序之神\n骑士村\n锁链环绕的剑盾\n\n\n中善\n坟墓之神\n海德尔堡\n灰色的十字墓碑\n\n\n中邪\n人偶之神\n斯派利城\n一只木偶手掌\n\n\n\n\n机关城\n\n\n\n混中\n战争之神\n克里堡\n染血的长矛和盾牌\n\n\n守邪\n诡术之神\n废墟城\n微笑的灰白面具\n\n\n守善\n自然之神\n维尔村\n黑色枯萎的树叶\n\n\n\n\n狂野之吻\n\n\n\n混中\n混沌之神\n混沌城\n∞\n\n\n混中\n熔铸之神\n沃特村\n锤子和铁砧\n\n\n\n\n布雷村\n\n\n\n\n\n托马村\n\n\n\n守邪\n狩猎之神\n瓦特城\n褐色的拉开长弓\n\n\n守善\n风暴之神\n恩琪村\n类似云朵的蓝白海浪\n\n\n中善\n守护之神\n米莱尔村\n银白半圆\n\n\n混中\n知识之神\n博卓村\n翻开的书籍\n\n\n守善\n引导之神\n沃斯利村\n十字星\n\n\n？\n初原与光芒之神\n？\n0\n\n\n？\n湮灭与黑暗之神\n？\n1\n\n\n？\n愚弄与欺诈之神\n？\n灰白面具上有一个黑色黑色泪滴\n\n\n绝对\n\n\n\n\n\n中立\n命运之神\n全大陆\n金属天平\n\n\n守邪\n死亡之神\n全大陆\n断开的镰刀\n\n\n混中\n梦境之神\n？\n倒立的人像\n\n\n"},{"url":"/2023/03/27/%E7%BB%84%E7%BB%87/","content":"组织秩序之锤荒域的一个骑士联盟，追求公正与绝对的秩序，信仰秩序之神，联盟中也有部分其他神的信仰者，只要不违背公正与秩序都能加入其中。联盟中会以阶级来区分等级，最高级的领导者被称为大骑士长，而其下是十三位大骑士都具有绝对的实力，第一骑士为实力最强的大骑士拥有的称号，称号按照实力决定。同时十三大骑士拥有决定推选大骑士长的票选，每十三年便会重新选举一次。十三骑士之下是银骑士，而银骑士拥有率领一支十三人小队的能力。所有新加入的人，都将接受一次来自苦修骑士的考核才能加入，之后将被授予秩序之锤骑士的身份，而苦修骑士只能由大骑士长来选出，大部分的苦修骑士都是退役了的十三骑士。秩序之锤的总部在骑士领，和学者领的法师有着紧密的联系，一位骑士进行任务的时候，通常学者领也会派出一名法师来协助。\n奥法联盟一个纯粹的学者联盟，只有对奥法有着深刻研究的人才能进入奥法联盟的中心，法师学徒进入其中必须选择一名导师，直到拥有了自己的招牌法术，才能算进入了奥法联盟的中心。其中不乏一切醉心于研究遗失法术的学者，很多时候普通人不愿意进入高塔给法师们送去一些物资。奥法联盟虽然有着十分多的分部在大陆上，那些只是普通的招收学徒的入口，真正的总部在学者领，如果没有指引者一般人是找不到进入的方法的。\n陆下影大陆上最为常见也是最为少见的组织，因为普通人很难找到陆下影这个组织的人，常见是因为陆下影的分部可能是旅店门口的一个杂货铺。陆下影的总部位于极东城，通常大陆上没有他们不知道的消息。组织分工十分的明确，负责出售情报的称为百晓生，负责暗杀的称为影刃，通常完成一些普通的委托的人称为小工。而加入其中的条件也十分简单，就是找到这个组织的总部或者分部，一个地区一个负责人，负责人由总部派人来担任。\n屠夫被所有教会城市通缉的组织，其中的每一个成员无一不是屠城灭村的刽子手，如果由于抹杀了一个城镇的生命而被通缉，他们会有人来邀请你前往废墟城的。目前没有人知道这个组织的头领是谁，也不知道他们组织这些穷凶极恶的家伙想要做什么。\n风涛一些海洋生物组成的联盟，为了对抗陆地掠夺者才成立的组织，只有生活在海中的种族才能加入，通常是为了自保，但是由于种族众多内部矛盾也十分的严重，为了生存领地经常大打出手，直到组织介入。\n沃克商盟荒域最大的商业联盟，良好的信誉让沃克商盟的成员商会在什么地方都能得到相应的尊敬，按照他们的口号：“金钱能买到的都不算珍贵”，你可以花钱在里面买到一切想要的物品，但是他们不涉奴隶交易。沃克商盟本身是一个商会，和大陆各地的城市交易都十分密切，不管是大量的武装还是雇佣兵都能以金钱来交换。\n灵魂天平和沃克商盟相反，灵魂天平其实才是真正能交易到一切物品的地方，无论是邪恶的物品还是奴隶，都能交易到。虽然名声恶臭，但是更多的人还是愿意前往寻找灵魂天平的交易地来交换物品，传闻在组织的背后是一位深渊的强大生物，如果没有买不起东西，甚至可以用灵魂来换取你想要的东西。\n皮言者皮言者主要活动在极西，其中的成员大多为智慧构装生物，或者进行了身体改造的类人生物为主，他们主要为了研究先进的机械物品，同时致力于灵魂方面的研究，众多研究者想要加入其中但都被拒之门外。\n疤痕橡树专门屠戮邪魔和深渊生物的组织，里面的成员将清除邪恶为己任，和秩序之锤不一样，他们为了清楚邪恶甚至可以做出一些其他的牺牲，即使是一个村子的普通人的性命。由于行使疯狂所以在其他城市风评并不是狠好，甚至在一些教会城市会遭到厌恶。\n奥凯西荒域的一个冒险者联盟，结构十分的松散，每个地方都会有奥凯西的冒险者工会，负责等级当地的冒险者，每个地区都有会长，每年都会轮流在其他的城市开会来决定重大的事宜。如果在要获得高报酬的委托，注册一支队伍便是最重要的，接取的任务越多，能够接触到的高报酬任务就越多。等级分别为：铁 铜 银 金 玉 铂。\n索伦汀如果说奥凯西是明面上的冒险者联盟，索伦汀就是属于黑暗面的冒险者联盟，通常一些邪魔或者被世人所厌恶的种族才会加入其中，但是不乏一些为了追求黑暗力量的冒险者们去其中探求力量。其中等级划分以此为：红、黑、灰、白。红纹的成员即为索伦汀的领导者，也只有一位，其下黑纹成员由9位力量强大的人组成，而所有历史上黑纹出现过的城市无一例外都从地图上被抹去了。索伦汀中有一些能够沟通深渊的特殊手段，为了利益即使让深渊再次回归他们也做得出来。其中一支最为活跃的索伦汀队伍是一队龙裔组成的掠夺者，其中最低级的人头都价值1000金币。\n自然之庭不管是极北还是极南，自然之庭都不会少，这是一群由德鲁伊和树精组成的联盟，他们致力于保持自然的平衡。在森林中吹响特定的口哨，会有一个妖精来指引你去往本地区自然之庭所在的地点。当一个地区的树精消逝，地区的自然就会失控，自然之庭便会出手干涉失控的自然生命。当着自然之庭成员的面破坏自然或者屠杀野兽将受到敌视。\n清道夫&#x2F;颂亡者以将游魂送入迷失境为目标的松散组织，和教会处于对立，而传说加入他们的人死后也将进入死亡之神的神国。\n"}]